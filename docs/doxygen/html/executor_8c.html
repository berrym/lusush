<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lusush Shell: src/executor.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Lusush Shell<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">A modern POSIX shell with GNU Readline integration</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('executor_8c.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">executor.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Modern Execution Engine Implementation.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="executor_8h_source.html">executor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="alias_8h_source.html">alias.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="arithmetic_8h_source.html">arithmetic.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="autocorrect_8h_source.html">autocorrect.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="builtins_8h_source.html">builtins.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="config_8h_source.html">config.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="debug_8h_source.html">debug.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ht_8h_source.html">ht.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="init_8h_source.html">init.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lle__shell__event__hub_8h_source.html">lle/lle_shell_event_hub.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lusush_8h_source.html">lusush.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="node_8h_source.html">node.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="parser_8h_source.html">parser.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="redirection_8h_source.html">redirection.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="signals_8h_source.html">signals.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="strings_8h_source.html">strings.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="symtable_8h_source.html">symtable.h</a>&quot;</code><br />
<code>#include &lt;ctype.h&gt;</code><br />
<code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;fcntl.h&gt;</code><br />
<code>#include &lt;glob.h&gt;</code><br />
<code>#include &lt;pwd.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;sys/stat.h&gt;</code><br />
<code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &lt;sys/wait.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;signal.h&gt;</code><br />
</div>
<p><a href="executor_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aebcc5fabe9b7d531cf55a2fe708d77df" id="r_aebcc5fabe9b7d531cf55a2fe708d77df"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebcc5fabe9b7d531cf55a2fe708d77df">execute_node</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *<a class="el" href="structnode.html">node</a>)</td></tr>
<tr class="memdesc:aebcc5fabe9b7d531cf55a2fe708d77df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core node execution dispatcher.  <br /></td></tr>
<tr class="memitem:aa515bb6b938557b14609b8133e6c0754" id="r_aa515bb6b938557b14609b8133e6c0754"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa515bb6b938557b14609b8133e6c0754">execute_command</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *command)</td></tr>
<tr class="memdesc:aa515bb6b938557b14609b8133e6c0754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a simple command node.  <br /></td></tr>
<tr class="memitem:af8d85406503ff5c8afae9fdb1c9b71b5" id="r_af8d85406503ff5c8afae9fdb1c9b71b5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8d85406503ff5c8afae9fdb1c9b71b5">execute_pipeline</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *pipeline)</td></tr>
<tr class="memdesc:af8d85406503ff5c8afae9fdb1c9b71b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a pipeline of commands.  <br /></td></tr>
<tr class="memitem:a11762008e135435d99006aa3b751ebdc" id="r_a11762008e135435d99006aa3b751ebdc"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11762008e135435d99006aa3b751ebdc">execute_function_definition</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *function)</td></tr>
<tr class="memitem:a7ef8919127781d872d5d1be6330acda6" id="r_a7ef8919127781d872d5d1be6330acda6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ef8919127781d872d5d1be6330acda6">execute_function_call</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, const char *function_name, char **argv, int argc)</td></tr>
<tr class="memitem:afdc21ec4aead52dbc2e25cc6d3de5cc8" id="r_afdc21ec4aead52dbc2e25cc6d3de5cc8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdc21ec4aead52dbc2e25cc6d3de5cc8">is_function_defined</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, const char *function_name)</td></tr>
<tr class="memitem:ac677e58947a4edf22eec7208cc22a3da" id="r_ac677e58947a4edf22eec7208cc22a3da"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="executor_8h.html#a4ff86c222eadffcfcce6f45bbe194029">function_def_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac677e58947a4edf22eec7208cc22a3da">find_function</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, const char *function_name)</td></tr>
<tr class="memitem:a50d296cbbc773a18f0ec69d88383f655" id="r_a50d296cbbc773a18f0ec69d88383f655"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50d296cbbc773a18f0ec69d88383f655">store_function</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, const char *function_name, <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *body, <a class="el" href="executor_8h.html#ac0f6db05e3be0c03ea208716041861d1">function_param_t</a> *params, int param_count)</td></tr>
<tr class="memitem:a3291a198aef87aa21f88b93ed6e6c02f" id="r_a3291a198aef87aa21f88b93ed6e6c02f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3291a198aef87aa21f88b93ed6e6c02f">validate_function_parameters</a> (<a class="el" href="executor_8h.html#a4ff86c222eadffcfcce6f45bbe194029">function_def_t</a> *func, char **argv, int argc)</td></tr>
<tr class="memitem:a1adf0cc8fe07d87ba8011ec389d9ec3c" id="r_a1adf0cc8fe07d87ba8011ec389d9ec3c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1adf0cc8fe07d87ba8011ec389d9ec3c">copy_ast_node</a> (<a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *<a class="el" href="structnode.html">node</a>)</td></tr>
<tr class="memitem:a207aacc7dda79c61d54bd23fb308ff76" id="r_a207aacc7dda79c61d54bd23fb308ff76"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a207aacc7dda79c61d54bd23fb308ff76">copy_ast_chain</a> (<a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *<a class="el" href="structnode.html">node</a>)</td></tr>
<tr class="memitem:ad7337071947be7db6f50a9b0626ef887" id="r_ad7337071947be7db6f50a9b0626ef887"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7337071947be7db6f50a9b0626ef887">execute_if</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *if_node)</td></tr>
<tr class="memdesc:ad7337071947be7db6f50a9b0626ef887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute an if statement.  <br /></td></tr>
<tr class="memitem:a6fb7c4ad0b7e369a35e2e6717ca73f12" id="r_a6fb7c4ad0b7e369a35e2e6717ca73f12"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fb7c4ad0b7e369a35e2e6717ca73f12">execute_while</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *while_node)</td></tr>
<tr class="memdesc:a6fb7c4ad0b7e369a35e2e6717ca73f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a while loop.  <br /></td></tr>
<tr class="memitem:afa465903e05bf8fdc05a7cd4e21dd8db" id="r_afa465903e05bf8fdc05a7cd4e21dd8db"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa465903e05bf8fdc05a7cd4e21dd8db">execute_until</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *until_node)</td></tr>
<tr class="memdesc:afa465903e05bf8fdc05a7cd4e21dd8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute an until loop.  <br /></td></tr>
<tr class="memitem:ad5b2439e18d1d45be354db76fb45de96" id="r_ad5b2439e18d1d45be354db76fb45de96"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5b2439e18d1d45be354db76fb45de96">execute_for</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *for_node)</td></tr>
<tr class="memdesc:ad5b2439e18d1d45be354db76fb45de96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a for loop.  <br /></td></tr>
<tr class="memitem:a31069b392c236239b782e95047fea273" id="r_a31069b392c236239b782e95047fea273"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31069b392c236239b782e95047fea273">execute_case</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *case_node)</td></tr>
<tr class="memitem:a95e0b4e9a11d338abcafb7526ee92d14" id="r_a95e0b4e9a11d338abcafb7526ee92d14"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95e0b4e9a11d338abcafb7526ee92d14">execute_logical_and</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *and_node)</td></tr>
<tr class="memdesc:a95e0b4e9a11d338abcafb7526ee92d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute logical AND operator (&amp;&amp;).  <br /></td></tr>
<tr class="memitem:a986ae10c01a19626f8b1196bebdaface" id="r_a986ae10c01a19626f8b1196bebdaface"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a986ae10c01a19626f8b1196bebdaface">execute_logical_or</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *or_node)</td></tr>
<tr class="memdesc:a986ae10c01a19626f8b1196bebdaface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute logical OR operator (||).  <br /></td></tr>
<tr class="memitem:ab1a288ac82fefb05701aa9074735c56f" id="r_ab1a288ac82fefb05701aa9074735c56f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1a288ac82fefb05701aa9074735c56f">execute_command_list</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *list)</td></tr>
<tr class="memdesc:ab1a288ac82fefb05701aa9074735c56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a sequence of commands.  <br /></td></tr>
<tr class="memitem:ae17335df5fa42d9058992bbc32d5ea63" id="r_ae17335df5fa42d9058992bbc32d5ea63"><td class="memItemLeft" align="right" valign="top">static char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae17335df5fa42d9058992bbc32d5ea63">build_argv_from_ast</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *command, int *argc)</td></tr>
<tr class="memdesc:ae17335df5fa42d9058992bbc32d5ea63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build argument vector from command AST.  <br /></td></tr>
<tr class="memitem:aeb75df071b89f0beaa7a6234e09916dd" id="r_aeb75df071b89f0beaa7a6234e09916dd"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb75df071b89f0beaa7a6234e09916dd">execute_external_command</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, char **argv)</td></tr>
<tr class="memitem:a9f49d270740eedc1d92703f6a58857f2" id="r_a9f49d270740eedc1d92703f6a58857f2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f49d270740eedc1d92703f6a58857f2">execute_external_command_with_redirection</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, char **argv, bool redirect_stderr)</td></tr>
<tr class="memitem:aa47981dbc29d238de71be5ce9263e5de" id="r_aa47981dbc29d238de71be5ce9263e5de"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa47981dbc29d238de71be5ce9263e5de">is_stdout_captured</a> (void)</td></tr>
<tr class="memitem:a01a1ef635b10c0c1f73ae027e25bb905" id="r_a01a1ef635b10c0c1f73ae027e25bb905"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01a1ef635b10c0c1f73ae027e25bb905">has_stdout_redirections</a> (<a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *command)</td></tr>
<tr class="memitem:a9dc16234881160b389b8849514bacb1f" id="r_a9dc16234881160b389b8849514bacb1f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9dc16234881160b389b8849514bacb1f">execute_builtin_with_captured_stdout</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, char **argv, <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *command)</td></tr>
<tr class="memitem:a64ef339abe8363103c92f9cf1ec57ff9" id="r_a64ef339abe8363103c92f9cf1ec57ff9"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64ef339abe8363103c92f9cf1ec57ff9">add_to_argv_list</a> (char ***argv_list, int *argv_count, int *argv_capacity, char *arg)</td></tr>
<tr class="memdesc:a64ef339abe8363103c92f9cf1ec57ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an argument to a dynamic argv list.  <br /></td></tr>
<tr class="memitem:a0e6ad81b6186b16d2d461ae2ea187c5c" id="r_a0e6ad81b6186b16d2d461ae2ea187c5c"><td class="memItemLeft" align="right" valign="top">static char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e6ad81b6186b16d2d461ae2ea187c5c">ifs_field_split</a> (const char *<a class="el" href="tokenizer_8c.html#a16343090e80c4472521560f30113d96c">text</a>, const char *ifs, int *<a class="el" href="custom__source_8c.html#a76d971a3c552bc58ba9f0d5fceae9806">count</a>)</td></tr>
<tr class="memdesc:a0e6ad81b6186b16d2d461ae2ea187c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split text into fields using IFS delimiters.  <br /></td></tr>
<tr class="memitem:a1595c3f36f971bc24bbff109fc3fd551" id="r_a1595c3f36f971bc24bbff109fc3fd551"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1595c3f36f971bc24bbff109fc3fd551">is_posix_mode_enabled</a> (void)</td></tr>
<tr class="memitem:ac80add05e51d4943255d11d44937b324" id="r_ac80add05e51d4943255d11d44937b324"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac80add05e51d4943255d11d44937b324">is_pipefail_enabled</a> (void)</td></tr>
<tr class="memitem:ae590f2fced7bd918ed39ee3629050828" id="r_ae590f2fced7bd918ed39ee3629050828"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae590f2fced7bd918ed39ee3629050828">execute_external_command_with_setup</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, char **argv, bool redirect_stderr, <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *command)</td></tr>
<tr class="memitem:a59d52807b3517f3dad4f4b4036c7a8da" id="r_a59d52807b3517f3dad4f4b4036c7a8da"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59d52807b3517f3dad4f4b4036c7a8da">execute_builtin_command</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, char **argv)</td></tr>
<tr class="memitem:a9dbc89cb676bec1e5b8c141ed6b66f1d" id="r_a9dbc89cb676bec1e5b8c141ed6b66f1d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9dbc89cb676bec1e5b8c141ed6b66f1d">execute_brace_group</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *group)</td></tr>
<tr class="memitem:a1a7378bea88f943f8dd65373a1b1767f" id="r_a1a7378bea88f943f8dd65373a1b1767f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a7378bea88f943f8dd65373a1b1767f">execute_subshell</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *subshell)</td></tr>
<tr class="memitem:ace283bf4be85f4b662474c8f96d10bc6" id="r_ace283bf4be85f4b662474c8f96d10bc6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace283bf4be85f4b662474c8f96d10bc6">is_builtin_command</a> (const char *cmd)</td></tr>
<tr class="memitem:aaae5b6b7c661d080e6352a8f63fb1b04" id="r_aaae5b6b7c661d080e6352a8f63fb1b04"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaae5b6b7c661d080e6352a8f63fb1b04">set_executor_error</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, const char *message)</td></tr>
<tr class="memdesc:aaae5b6b7c661d080e6352a8f63fb1b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an error on the executor.  <br /></td></tr>
<tr class="memitem:a581de7e6ab02ee64c6f6c89ca72b5f09" id="r_a581de7e6ab02ee64c6f6c89ca72b5f09"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a581de7e6ab02ee64c6f6c89ca72b5f09">expand_variable</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, const char *var_text)</td></tr>
<tr class="memitem:afa926ce63c9d5b9ab94018579bc8735a" id="r_afa926ce63c9d5b9ab94018579bc8735a"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa926ce63c9d5b9ab94018579bc8735a">expand_tilde</a> (const char *<a class="el" href="tokenizer_8c.html#a16343090e80c4472521560f30113d96c">text</a>)</td></tr>
<tr class="memitem:a1fdd06789897d80bc145c64329d4528b" id="r_a1fdd06789897d80bc145c64329d4528b"><td class="memItemLeft" align="right" valign="top">static char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fdd06789897d80bc145c64329d4528b">expand_glob_pattern</a> (const char *pattern, int *expanded_count)</td></tr>
<tr class="memitem:a0f3bcfecb2b7169220221548fcdff65e" id="r_a0f3bcfecb2b7169220221548fcdff65e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f3bcfecb2b7169220221548fcdff65e">needs_glob_expansion</a> (const char *str)</td></tr>
<tr class="memitem:a532b3d93ddecde5f7a3abc71c2c8996f" id="r_a532b3d93ddecde5f7a3abc71c2c8996f"><td class="memItemLeft" align="right" valign="top">static char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a532b3d93ddecde5f7a3abc71c2c8996f">expand_brace_pattern</a> (const char *pattern, int *expanded_count)</td></tr>
<tr class="memitem:a7f5cf712959b1ffcb8d98982da06e608" id="r_a7f5cf712959b1ffcb8d98982da06e608"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f5cf712959b1ffcb8d98982da06e608">needs_brace_expansion</a> (const char *str)</td></tr>
<tr class="memitem:a4f2288fe86c9ffe5f48768a6fe941b5b" id="r_a4f2288fe86c9ffe5f48768a6fe941b5b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f2288fe86c9ffe5f48768a6fe941b5b">initialize_job_control</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>)</td></tr>
<tr class="memitem:a2374b6e1dbfbe98e1c79e59dd5360a50" id="r_a2374b6e1dbfbe98e1c79e59dd5360a50"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2374b6e1dbfbe98e1c79e59dd5360a50">expand_arithmetic</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, const char *arith_text)</td></tr>
<tr class="memitem:a08153adbce7290e076b7162f47fa7d39" id="r_a08153adbce7290e076b7162f47fa7d39"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08153adbce7290e076b7162f47fa7d39">expand_command_substitution</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, const char *cmd_text)</td></tr>
<tr class="memitem:a0a18d6faec574fe77a9727bb3ddd604e" id="r_a0a18d6faec574fe77a9727bb3ddd604e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a18d6faec574fe77a9727bb3ddd604e">copy_node_simple</a> (<a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *original)</td></tr>
<tr class="memdesc:a0a18d6faec574fe77a9727bb3ddd604e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple recursive node copy.  <br /></td></tr>
<tr class="memitem:a353790498bc6052099e9020511cc93f1" id="r_a353790498bc6052099e9020511cc93f1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a353790498bc6052099e9020511cc93f1">copy_function_definitions</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *dest, <a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *src)</td></tr>
<tr class="memdesc:a353790498bc6052099e9020511cc93f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand variables, arithmetic, and command substitutions if needed.  <br /></td></tr>
<tr class="memitem:ac33dd755c5ac9849667a7c621af907d7" id="r_ac33dd755c5ac9849667a7c621af907d7"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac33dd755c5ac9849667a7c621af907d7">expand_if_needed</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, const char *<a class="el" href="tokenizer_8c.html#a16343090e80c4472521560f30113d96c">text</a>)</td></tr>
<tr class="memitem:a98a44ad874c697e1bf44d92f5481b5a2" id="r_a98a44ad874c697e1bf44d92f5481b5a2"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98a44ad874c697e1bf44d92f5481b5a2">expand_quoted_string</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, const char *str)</td></tr>
<tr class="memitem:a3b6e605d61c1af767a519410f61f85dc" id="r_a3b6e605d61c1af767a519410f61f85dc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b6e605d61c1af767a519410f61f85dc">is_assignment</a> (const char *<a class="el" href="tokenizer_8c.html#a16343090e80c4472521560f30113d96c">text</a>)</td></tr>
<tr class="memitem:aa0b9870b4ce2412b4a9e456741916790" id="r_aa0b9870b4ce2412b4a9e456741916790"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0b9870b4ce2412b4a9e456741916790">execute_assignment</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, const char *assignment)</td></tr>
<tr class="memitem:a00f062e9edf50854864902595dbb91f0" id="r_a00f062e9edf50854864902595dbb91f0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00f062e9edf50854864902595dbb91f0">match_pattern</a> (const char *str, const char *pattern)</td></tr>
<tr class="memitem:a1d3d31c65b2394077e5dd363bbdbae0d" id="r_a1d3d31c65b2394077e5dd363bbdbae0d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d3d31c65b2394077e5dd363bbdbae0d">is_privileged_command_allowed</a> (const char *command)</td></tr>
<tr class="memdesc:a1d3d31c65b2394077e5dd363bbdbae0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if command is allowed in privileged mode.  <br /></td></tr>
<tr class="memitem:a182eb179c5c84fd514c227613822bbac" id="r_a182eb179c5c84fd514c227613822bbac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a182eb179c5c84fd514c227613822bbac">is_privileged_redirection_allowed</a> (const char *target)</td></tr>
<tr class="memdesc:a182eb179c5c84fd514c227613822bbac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if redirection target is allowed in privileged mode.  <br /></td></tr>
<tr class="memitem:a3afc6a154b62137a3cc1f109459919d9" id="r_a3afc6a154b62137a3cc1f109459919d9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3afc6a154b62137a3cc1f109459919d9">is_privileged_path_modification_allowed</a> (const char *var_name)</td></tr>
<tr class="memdesc:a3afc6a154b62137a3cc1f109459919d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if environment variable modification is allowed in privileged mode.  <br /></td></tr>
<tr class="memitem:a739b7e1a070f9f04198ba27a43f106c8" id="r_a739b7e1a070f9f04198ba27a43f106c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a739b7e1a070f9f04198ba27a43f106c8">executor_new</a> (void)</td></tr>
<tr class="memdesc:a739b7e1a070f9f04198ba27a43f106c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new executor with global symbol table.  <br /></td></tr>
<tr class="memitem:aef99707c58e0267bc37a9998f6675f91" id="r_aef99707c58e0267bc37a9998f6675f91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef99707c58e0267bc37a9998f6675f91">executor_new_with_symtable</a> (<a class="el" href="symtable_8h.html#affe05f5e84088a0115fe736424205a86">symtable_manager_t</a> *symtable)</td></tr>
<tr class="memdesc:aef99707c58e0267bc37a9998f6675f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new executor with specified symbol table.  <br /></td></tr>
<tr class="memitem:a5fd8c68484dbb3118e1fa580d6b76b5f" id="r_a5fd8c68484dbb3118e1fa580d6b76b5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fd8c68484dbb3118e1fa580d6b76b5f">executor_free</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>)</td></tr>
<tr class="memdesc:a5fd8c68484dbb3118e1fa580d6b76b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an executor and all associated resources.  <br /></td></tr>
<tr class="memitem:a6b1cdebbbebe8e5ec2af73d2c3a9f3a0" id="r_a6b1cdebbbebe8e5ec2af73d2c3a9f3a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b1cdebbbebe8e5ec2af73d2c3a9f3a0">executor_set_debug</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, bool debug)</td></tr>
<tr class="memdesc:a6b1cdebbbebe8e5ec2af73d2c3a9f3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable debug mode.  <br /></td></tr>
<tr class="memitem:a4434d018255a2a080eacecce7033436f" id="r_a4434d018255a2a080eacecce7033436f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4434d018255a2a080eacecce7033436f">executor_set_interactive</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, bool interactive)</td></tr>
<tr class="memdesc:a4434d018255a2a080eacecce7033436f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interactive mode flag.  <br /></td></tr>
<tr class="memitem:af5a13b7516cbee2e0ff946ab74b5a70e" id="r_af5a13b7516cbee2e0ff946ab74b5a70e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5a13b7516cbee2e0ff946ab74b5a70e">executor_set_symtable</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, <a class="el" href="symtable_8h.html#affe05f5e84088a0115fe736424205a86">symtable_manager_t</a> *symtable)</td></tr>
<tr class="memdesc:af5a13b7516cbee2e0ff946ab74b5a70e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the symbol table manager.  <br /></td></tr>
<tr class="memitem:a7e65660a63ec9184530f526a264ba75f" id="r_a7e65660a63ec9184530f526a264ba75f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e65660a63ec9184530f526a264ba75f">executor_set_script_context</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, const char *script_file, int line_number)</td></tr>
<tr class="memdesc:a7e65660a63ec9184530f526a264ba75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set script execution context for debugging.  <br /></td></tr>
<tr class="memitem:a446f70a034fe775f6f070a247c2c23ad" id="r_a446f70a034fe775f6f070a247c2c23ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a446f70a034fe775f6f070a247c2c23ad">executor_clear_script_context</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>)</td></tr>
<tr class="memdesc:a446f70a034fe775f6f070a247c2c23ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear script execution context.  <br /></td></tr>
<tr class="memitem:a29c5fc83dbc17a32fde0f38320a8541f" id="r_a29c5fc83dbc17a32fde0f38320a8541f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29c5fc83dbc17a32fde0f38320a8541f">executor_get_current_script_file</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>)</td></tr>
<tr class="memdesc:a29c5fc83dbc17a32fde0f38320a8541f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current script file path.  <br /></td></tr>
<tr class="memitem:ab0bfb08a579746c037a94a32f0ad1e8c" id="r_ab0bfb08a579746c037a94a32f0ad1e8c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0bfb08a579746c037a94a32f0ad1e8c">executor_get_current_script_line</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>)</td></tr>
<tr class="memdesc:ab0bfb08a579746c037a94a32f0ad1e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current script line number.  <br /></td></tr>
<tr class="memitem:a03faf0840b3389787512d7c75e91e132" id="r_a03faf0840b3389787512d7c75e91e132"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03faf0840b3389787512d7c75e91e132">executor_has_error</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>)</td></tr>
<tr class="memdesc:a03faf0840b3389787512d7c75e91e132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if executor has an error.  <br /></td></tr>
<tr class="memitem:a64da5926bfc183927a4ea1b799668752" id="r_a64da5926bfc183927a4ea1b799668752"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64da5926bfc183927a4ea1b799668752">executor_error</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>)</td></tr>
<tr class="memdesc:a64da5926bfc183927a4ea1b799668752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last error message.  <br /></td></tr>
<tr class="memitem:aec030f6ca5669a342a720e6f839621ce" id="r_aec030f6ca5669a342a720e6f839621ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec030f6ca5669a342a720e6f839621ce">executor_execute</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *ast)</td></tr>
<tr class="memdesc:aec030f6ca5669a342a720e6f839621ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute an AST node.  <br /></td></tr>
<tr class="memitem:abe2e9629c5153b82bd7dfa821937f1bc" id="r_abe2e9629c5153b82bd7dfa821937f1bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe2e9629c5153b82bd7dfa821937f1bc">executor_execute_command_line</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, const char *input)</td></tr>
<tr class="memdesc:abe2e9629c5153b82bd7dfa821937f1bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse and execute a command line string.  <br /></td></tr>
<tr class="memitem:aa11d6858edb1cbb30ffed009dc466935" id="r_aa11d6858edb1cbb30ffed009dc466935"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa11d6858edb1cbb30ffed009dc466935">execute_command_chain</a> (<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *<a class="el" href="structexecutor.html">executor</a>, <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *first_command)</td></tr>
<tr class="memdesc:aa11d6858edb1cbb30ffed009dc466935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a chain of sibling commands.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa6126a46019a074d653f294cc2af4208" id="r_aa6126a46019a074d653f294cc2af4208"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6126a46019a074d653f294cc2af4208">current_executor</a> = NULL</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Modern Execution Engine Implementation. </p>
<p>Clean, efficient execution engine designed for the modern parser and tokenizer. Handles command execution, control structures, pipelines, and variable management with proper POSIX compliance.</p>
<dl class="section author"><dt>Author</dt><dd>Michael Berry <a href="#" onclick="location.href='mai'+'lto:'+'tri'+'sm'+'egu'+'st'+'is@'+'gm'+'ail'+'.c'+'om'; return false;">trism<span class="obfuscator">.nosp@m.</span>egus<span class="obfuscator">.nosp@m.</span>tis@g<span class="obfuscator">.nosp@m.</span>mail<span class="obfuscator">.nosp@m.</span>.com</a> </dd></dl>

<p class="definition">Definition in file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a64ef339abe8363103c92f9cf1ec57ff9" name="a64ef339abe8363103c92f9cf1ec57ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ef339abe8363103c92f9cf1ec57ff9">&#9670;&#160;</a></span>add_to_argv_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int add_to_argv_list </td>
          <td>(</td>
          <td class="paramtype">char ***</td>          <td class="paramname"><span class="paramname"><em>argv_list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>argv_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>argv_capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an argument to a dynamic argv list. </p>
<p>Dynamically grows the argument list as needed, doubling capacity when full. Used during command argument building.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argv_list</td><td>Pointer to argument array </td></tr>
    <tr><td class="paramname">argv_count</td><td>Pointer to current count </td></tr>
    <tr><td class="paramname">argv_capacity</td><td>Pointer to current capacity </td></tr>
    <tr><td class="paramname">arg</td><td>Argument string to add (ownership transferred) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 on allocation failure </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l01793">1793</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="ae17335df5fa42d9058992bbc32d5ea63" name="ae17335df5fa42d9058992bbc32d5ea63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17335df5fa42d9058992bbc32d5ea63">&#9670;&#160;</a></span>build_argv_from_ast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char ** build_argv_from_ast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>command</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build argument vector from command AST. </p>
<p>Constructs argv array from command node, performing:</p><ul>
<li>Variable expansion</li>
<li>Brace expansion</li>
<li>Glob expansion</li>
<li>IFS field splitting Excludes redirection nodes from the argument list.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context for variable lookup </td></tr>
    <tr><td class="paramname">command</td><td>Command node to process </td></tr>
    <tr><td class="paramname">argc</td><td>Output: argument count </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL-terminated argv array (caller must free), or NULL on error </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l01907">1907</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="a207aacc7dda79c61d54bd23fb308ff76" name="a207aacc7dda79c61d54bd23fb308ff76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a207aacc7dda79c61d54bd23fb308ff76">&#9670;&#160;</a></span>copy_ast_chain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> * copy_ast_chain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1adf0cc8fe07d87ba8011ec389d9ec3c" name="a1adf0cc8fe07d87ba8011ec389d9ec3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adf0cc8fe07d87ba8011ec389d9ec3c">&#9670;&#160;</a></span>copy_ast_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> * copy_ast_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a353790498bc6052099e9020511cc93f1" name="a353790498bc6052099e9020511cc93f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353790498bc6052099e9020511cc93f1">&#9670;&#160;</a></span>copy_function_definitions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base__terminal_8h.html#a07d932791f722cd5b75c111e51ef2023">MAYBE_UNUSED</a> void copy_function_definitions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expand variables, arithmetic, and command substitutions if needed. </p>
<p>Checks text for expansion markers ($, ~, `) and applies appropriate expansion. Handles tilde expansion, variable expansion, arithmetic expansion $((...)), and command substitution $(...).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context for variable lookup </td></tr>
    <tr><td class="paramname">text</td><td>Text to potentially expand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Expanded string (caller must free), or copy of original */ char *expand_if_needed(<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *executor, const char *text) { if (!executor || !text) { return NULL; }</dd></dl>
<p>Check for tilde expansion first if (text[0] == '~') { char *tilde_expanded = expand_tilde(text); if (tilde_expanded &amp;&amp; strcmp(tilde_expanded, text) != 0) { Tilde was expanded, now check if result needs variable expansion const char *first_dollar = strchr(tilde_expanded, '$'); if (first_dollar) { char *final_result = expand_quoted_string(executor, tilde_expanded); free(tilde_expanded); return final_result; } return tilde_expanded; } if (tilde_expanded) { free(tilde_expanded); } }</p>
<p>Check if this looks like it contains variables (has $) This is a heuristic for expandable strings const char *first_dollar = strchr(text, '$'); if (first_dollar) { Count dollar signs to determine if we have multiple variables int dollar_count = 0; for (const char *p = text; *p; p++) { if (*p == '$') { dollar_count++; } }</p>
<p>If we have multiple dollar signs or the first dollar is not at position 0, treat as quoted string with multiple expansions if (dollar_count &gt; 1 || first_dollar != text) { return expand_quoted_string(executor, text); }</p>
<p>Single expansion starting at position 0 if (strncmp(text, "$((", 3) == 0) { return expand_arithmetic(executor, text); } else if (strncmp(text, "$(", 2) == 0) { return expand_command_substitution(executor, text); } else { return expand_variable(executor, text); } }</p>
<p>Check for backtick command substitution if (text[0] == '`') { return expand_command_substitution(executor, text); }</p>
<p>// Regular text - just duplicate return strdup(text); }</p>
<p>/**</p>
<p>Execute an external command</p>
<p>Forks and executes an external command using execvp. Handles command hashing for faster subsequent lookups.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">argv</td><td>NULL-terminated argument vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exit status of command (127 for not found, 126 for permission denied) */ MAYBE_UNUSED static int <a class="el" href="#aeb75df071b89f0beaa7a6234e09916dd">execute_external_command(executor_t *executor, char **argv)</a> { return execute_external_command_with_redirection(executor, argv, false); }</dd></dl>
<p>/**</p>
<p>Execute external command with optional stderr redirection</p>
<p>Forks and executes an external command, optionally redirecting stderr to /dev/null. Handles command hashing and proper signal handling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">argv</td><td>NULL-terminated argument vector </td></tr>
    <tr><td class="paramname">redirect_stderr</td><td>If true, redirect stderr to /dev/null </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exit status of command */ static int <a class="el" href="#a9f49d270740eedc1d92703f6a58857f2">execute_external_command_with_redirection(executor_t *executor,
                                                     char **argv,
                                                     bool redirect_stderr)</a> { if (!argv || !argv[0]) { return 1; }</dd></dl>
<p>// If hashall is enabled, remember this command's location before forking if (shell_opts.hash_commands &amp;&amp; !strchr(argv[0], '/')) { char *full_path = find_command_in_path(argv[0]); if (full_path) { <a class="el" href="builtins_8c.html#a989d135a74211ab7bafe3b9f62ec0af7" title="Initialize the command hash table.">init_command_hash()</a>; if (command_hash) { ht_strstr_insert(command_hash, argv[0], full_path); } free(full_path); } }</p>
<p>// Reset terminal state before forking for external commands // This ensures git and other commands get proper TTY behavior if (<a class="el" href="init_8c.html#a580c2915388997747a6a41cd4b9a7b09">is_interactive_shell()</a>) { fflush(stdout); fflush(stderr); }</p>
<p>pid_t pid = fork(); if (pid == -1) { set_executor_error(executor, "Failed to fork"); return 1; }</p>
<p>if (pid == 0) { // Child process if (redirect_stderr) { // Redirect stderr to /dev/null int null_fd = open("/dev/null", O_WRONLY); if (null_fd != -1) { dup2(null_fd, STDERR_FILENO); close(null_fd); } }</p>
<p>execvp(argv[0], argv); // Check errno to determine appropriate exit code int exit_code = 127; // Default: command not found if (errno == EACCES) { exit_code = 126; // Permission denied } else if (errno == ENOENT) { exit_code = 127; // Command not found } if (!redirect_stderr) { perror(argv[0]); } exit(exit_code); } else { // Parent process set_current_child_pid(pid);</p>
<p>// Print trace for external command if -x is enabled if (<a class="el" href="posix__opts_8c.html#a229813ff81324b97887ad109b8d1b322">should_trace_execution()</a>) { // Build command string from argv for tracing size_t cmd_len = 1; // for null terminator for (int j = 0; argv[j]; j++) { cmd_len += strlen(argv[j]) + (j &gt; 0 ? 1 : 0); // +1 for space }</p>
<p>char *cmd_str = malloc(cmd_len); if (cmd_str) { strcpy(cmd_str, argv[0]); for (int j = 1; argv[j]; j++) { strcat(cmd_str, " "); strcat(cmd_str, argv[j]); } print_command_trace(cmd_str); free(cmd_str); } }</p>
<p>// Enhanced debug tracing for external commands <a class="el" href="debug_8h.html#a00dd1fcbfd09f1552c3d58ad35153dfb">DEBUG_TRACE_COMMAND(argv[0], argv, 0)</a>; <a class="el" href="debug_8h.html#a6bb0fa32df2669306b410e7c5432fb43">DEBUG_PROFILE_ENTER(argv[0])</a>;</p>
<p>int status; // Wait for child, retrying on EINTR (signal interruption) while (waitpid(pid, &amp;status, 0) == -1) { if (errno != EINTR) { // Real error - child may have already been reaped <a class="el" href="signals_8c.html#a2999df5d017596c8d43201547db5f44d">clear_current_child_pid()</a>; return 1; } // EINTR - signal interrupted wait, continue waiting } <a class="el" href="signals_8c.html#a2999df5d017596c8d43201547db5f44d">clear_current_child_pid()</a>;</p>
<p><a class="el" href="debug_8h.html#ae0d8879547ccfd85d78f178fc54bafd2">DEBUG_PROFILE_EXIT(argv[0])</a>;</p>
<p>// Handle exit status properly - child may have exited or been signaled if (WIFEXITED(status)) { return WEXITSTATUS(status); } else if (WIFSIGNALED(status)) { // Child was killed by signal - return 128 + signal number (bash // convention) return 128 + WTERMSIG(status); } return 1; } }</p>
<p>/**</p>
<p>Execute a brace group { commands; }</p>
<p>Executes commands within braces in the current shell context (not a subshell). Useful for grouping commands for redirection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">group</td><td>Brace group node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exit status of last command in group */ static int <a class="el" href="#a9dbc89cb676bec1e5b8c141ed6b66f1d">execute_brace_group(executor_t *executor, node_t *group)</a> { if (!group || group-&gt;type != NODE_BRACE_GROUP) { return 1; }</dd></dl>
<p>int last_result = 0; <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *command = group-&gt;first_child;</p>
<p>while (command) { last_result = execute_node(executor, command);</p>
<p>if (executor-&gt;debug) { printf("DEBUG: Brace group command result: %d\n", last_result); }</p>
<p>command = command-&gt;next_sibling; }</p>
<p>return last_result; }</p>
<p>/**</p>
<p>Execute a subshell ( commands )</p>
<p>Forks a child process and executes commands in that subshell. Variable changes in the subshell do not affect the parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">subshell</td><td>Subshell node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exit status of subshell */ static int <a class="el" href="#a1a7378bea88f943f8dd65373a1b1767f">execute_subshell(executor_t *executor, node_t *subshell)</a> { if (!subshell || subshell-&gt;type != NODE_SUBSHELL) { return 1; }</dd></dl>
<p>// Fork a new process for the subshell pid_t pid = fork(); if (pid == -1) { set_executor_error(executor, "Failed to fork for subshell"); return 1; }</p>
<p>if (pid == 0) { // Child process - execute commands in subshell environment int last_result = 0; <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *command = subshell-&gt;first_child;</p>
<p>while (command) { last_result = execute_node(executor, command); command = command-&gt;next_sibling; }</p>
<p>// Exit with the last command's result exit(last_result); } else { // Parent process - wait for subshell to complete int status; // Wait for child, retrying on EINTR (signal interruption) while (waitpid(pid, &amp;status, 0) == -1 &amp;&amp; errno == EINTR) ;</p>
<p>int result; if (WIFEXITED(status)) { result = WEXITSTATUS(status); } else if (WIFSIGNALED(status)) { // Child was killed by signal - return 128 + signal number (bash // convention) result = 128 + WTERMSIG(status); } else { result = 1; // Abnormal termination }</p>
<p>return result; } }</p>
<p>/**</p>
<p>Expand glob pattern to matching filenames</p>
<p>Uses system glob() function to expand patterns like *.c, ?.txt. Returns original pattern if no matches (POSIX behavior). Respects set -f (no_globbing) option.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>Glob pattern to expand </td></tr>
    <tr><td class="paramname">expanded_count</td><td>Output: number of matches </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of matching paths (caller must free), or NULL on error */ static char **expand_glob_pattern(const char *pattern, int *expanded_count) { if (!pattern || !expanded_count) { *expanded_count = 0; return NULL; }</dd></dl>
<p>// Check if globbing is disabled (set -f) if (shell_opts.no_globbing) { // Return the original pattern without expansion char **result = malloc(sizeof(char *)); if (result) { result[0] = strdup(pattern); *expanded_count = 1; return result; } *expanded_count = 0; return NULL; }</p>
<p>glob_t globbuf; int glob_result = glob(pattern, GLOB_NOSORT, NULL, &amp;globbuf);</p>
<p>if (glob_result == GLOB_NOMATCH) { // No matches - return original pattern (POSIX behavior) char **result = malloc(2 * sizeof(char *)); if (result) { result[0] = strdup(pattern); result[1] = NULL; *expanded_count = 1; } else { *expanded_count = 0; } return result; } else if (glob_result != 0) { // Error in globbing *expanded_count = 0; return NULL; }</p>
<p>// Success - copy results *expanded_count = globbuf.gl_pathc; char **result = malloc((globbuf.gl_pathc + 1) * sizeof(char *)); if (!result) { globfree(&amp;globbuf); *expanded_count = 0; return NULL; }</p>
<p>for (size_t i = 0; i &lt; globbuf.gl_pathc; i++) { result[i] = strdup(globbuf.gl_pathv[i]);</p>
<p>if (!result[i]) { // Cleanup on allocation failure for (size_t j = 0; j &lt; i; j++) { free(result[j]); } free(result); globfree(&amp;globbuf); *expanded_count = 0; return NULL; } } result[globbuf.gl_pathc] = NULL;</p>
<p>globfree(&amp;globbuf); return result; }</p>
<p>/**</p>
<p>Check if string contains glob metacharacters</p>
<p>Checks for *, ?, and [...] character class patterns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if glob expansion is needed */ static bool <a class="el" href="#a0f3bcfecb2b7169220221548fcdff65e">needs_glob_expansion(const char *str)</a> { if (!str) { return false; }</dd></dl>
<p>// Check for glob metacharacters: <em>, ?, and character classes [...] while (*str) { if (*str == '</em>' || *str == '?' || *str == '[') { return true; } str++; } return false; }</p>
<p>/**</p>
<p>Check if string contains brace expansion patterns</p>
<p>Checks for {a,b,c} style patterns with comma separators.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if brace expansion is needed */ static bool <a class="el" href="#a7f5cf712959b1ffcb8d98982da06e608">needs_brace_expansion(const char *str)</a> { if (!str) { return false; }</dd></dl>
<p>// Check for brace expansion patterns: {a,b,c} const char *p = str; while (*p) { if (*p == '{') { // Look for comma and closing brace const char *comma = strchr(p + 1, ','); const char *close = strchr(p + 1, '}'); if (comma &amp;&amp; close &amp;&amp; comma &lt; close) { return true; } } p++; } return false; }</p>
<p>/**</p>
<p>Expand brace patterns like {a,b,c}</p>
<p>Expands patterns like file.{c,h} into [file.c, file.h]. Handles prefix and suffix around the braces.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>Pattern containing braces </td></tr>
    <tr><td class="paramname">expanded_count</td><td>Output: number of expansions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of expanded strings (caller must free), or NULL on error */ static char **expand_brace_pattern(const char *pattern, int *expanded_count) { if (!pattern || !expanded_count) { *expanded_count = 0; return NULL; }</dd></dl>
<p>// Find the first brace pattern const char *open = strchr(pattern, '{'); if (!open) { // No braces - return original pattern char **result = malloc(2 * sizeof(char *)); if (result) { result[0] = strdup(pattern); result[1] = NULL; *expanded_count = 1; } else { *expanded_count = 0; } return result; }</p>
<p>const char *close = strchr(open + 1, '}'); if (!close) { // Malformed brace - return original pattern char **result = malloc(2 * sizeof(char *)); if (result) { result[0] = strdup(pattern); result[1] = NULL; *expanded_count = 1; } else { *expanded_count = 0; } return result; }</p>
<p>// Extract prefix, brace content, and suffix size_t prefix_len = open - pattern; size_t content_len = close - open - 1; const char *suffix = close + 1;</p>
<p>char *prefix = malloc(prefix_len + 1); char *content = malloc(content_len + 1); if (!prefix || !content) { free(prefix); free(content); *expanded_count = 0; return NULL; }</p>
<p>strncpy(prefix, pattern, prefix_len); prefix[prefix_len] = '\0'; strncpy(content, open + 1, content_len); content[content_len] = '\0';</p>
<p>// Count comma-separated items int item_count = 1; for (const char *p = content; *p; p++) { if (*p == ',') { item_count++; } }</p>
<p>// Allocate result array char **result = malloc((item_count + 1) * sizeof(char *)); if (!result) { free(prefix); free(content); *expanded_count = 0; return NULL; }</p>
<p>// Split content by commas and build result strings int result_index = 0; char *item_start = content; char *comma_pos = content;</p>
<p>while (result_index &lt; item_count) { // Find next comma or end of string while (*comma_pos &amp;&amp; *comma_pos != ',') { comma_pos++; }</p>
<p>// Extract current item size_t item_len = comma_pos - item_start; char *item = malloc(item_len + 1); if (!item) { // Cleanup on failure for (int i = 0; i &lt; result_index; i++) { free(result[i]); } free(result); free(prefix); free(content); *expanded_count = 0; return NULL; } strncpy(item, item_start, item_len); item[item_len] = '\0';</p>
<p>// Build full result string: prefix + item + suffix size_t full_len = strlen(prefix) + strlen(item) + strlen(suffix); result[result_index] = malloc(full_len + 1); if (!result[result_index]) { // Cleanup on failure free(item); for (int i = 0; i &lt; result_index; i++) { free(result[i]); } free(result); free(prefix); free(content); *expanded_count = 0; return NULL; }</p>
<p>strcpy(result[result_index], prefix); strcat(result[result_index], item); strcat(result[result_index], suffix);</p>
<p>free(item); result_index++;</p>
<p>// Move to next item if (*comma_pos == ',') { comma_pos++; item_start = comma_pos; } }</p>
<p>result[item_count] = NULL; *expanded_count = item_count;</p>
<p>free(prefix); free(content); return result; }</p>
<p>/**</p>
<p>Execute external command with full redirection setup</p>
<p>Forks and sets up redirections in the child process before exec. Handles command hashing, tracing (set -x), and debug profiling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">argv</td><td>NULL-terminated argument vector </td></tr>
    <tr><td class="paramname">redirect_stderr</td><td>If true, redirect stderr to /dev/null </td></tr>
    <tr><td class="paramname">command</td><td>Command node for redirection setup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exit status of command */ static int <a class="el" href="#ae590f2fced7bd918ed39ee3629050828">execute_external_command_with_setup(executor_t *executor,
                                               char **argv,
                                               bool redirect_stderr,
                                               node_t *command)</a> { if (!argv || !argv[0]) { return 1; }</dd></dl>
<p>// If hashall is enabled, remember this command's location before forking if (shell_opts.hash_commands &amp;&amp; !strchr(argv[0], '/')) { char *full_path = find_command_in_path(argv[0]); if (full_path) { <a class="el" href="builtins_8c.html#a989d135a74211ab7bafe3b9f62ec0af7" title="Initialize the command hash table.">init_command_hash()</a>; if (command_hash) { ht_strstr_insert(command_hash, argv[0], full_path); } free(full_path); } }</p>
<p>// Reset terminal state before forking for external commands // This ensures git and other commands get proper TTY behavior if (<a class="el" href="init_8c.html#a580c2915388997747a6a41cd4b9a7b09">is_interactive_shell()</a>) { fflush(stdout); fflush(stderr); }</p>
<p>pid_t pid = fork(); if (pid == -1) { set_executor_error(executor, "Failed to fork"); return 1; }</p>
<p>if (pid == 0) { // Child process - setup redirections here int redir_result = setup_redirections(executor, command); if (redir_result != 0) { exit(1); }</p>
<p>if (redirect_stderr) { // Redirect stderr to /dev/null int null_fd = open("/dev/null", O_WRONLY); if (null_fd != -1) { dup2(null_fd, STDERR_FILENO); close(null_fd); } }</p>
<p>execvp(argv[0], argv); // Check errno to determine appropriate exit code int exit_code = 127; // Default: command not found if (errno == EACCES) { exit_code = 126; // Permission denied } else if (errno == ENOENT) { exit_code = 127; // Command not found } if (!redirect_stderr) { perror(argv[0]); } exit(exit_code); } else { // Parent process set_current_child_pid(pid);</p>
<p>// Print trace for external command if -x is enabled if (<a class="el" href="posix__opts_8c.html#a229813ff81324b97887ad109b8d1b322">should_trace_execution()</a>) { // Build command string from argv for tracing size_t cmd_len = 1; // for null terminator for (int j = 0; argv[j]; j++) { cmd_len += strlen(argv[j]) + (j &gt; 0 ? 1 : 0); // +1 for space }</p>
<p>char *cmd_str = malloc(cmd_len); if (cmd_str) { strcpy(cmd_str, argv[0]); for (int j = 1; argv[j]; j++) { strcat(cmd_str, " "); strcat(cmd_str, argv[j]); } print_command_trace(cmd_str); free(cmd_str); } }</p>
<p>// Enhanced debug tracing for external commands with setup <a class="el" href="debug_8h.html#a00dd1fcbfd09f1552c3d58ad35153dfb">DEBUG_TRACE_COMMAND(argv[0], argv, 0)</a>; <a class="el" href="debug_8h.html#a6bb0fa32df2669306b410e7c5432fb43">DEBUG_PROFILE_ENTER(argv[0])</a>;</p>
<p>int status; // Wait for child, retrying on EINTR (signal interruption) while (waitpid(pid, &amp;status, 0) == -1) { if (errno != EINTR) { // Real error - child may have already been reaped <a class="el" href="signals_8c.html#a2999df5d017596c8d43201547db5f44d">clear_current_child_pid()</a>; return 1; } // EINTR - signal interrupted wait, continue waiting } <a class="el" href="signals_8c.html#a2999df5d017596c8d43201547db5f44d">clear_current_child_pid()</a>;</p>
<p><a class="el" href="debug_8h.html#ae0d8879547ccfd85d78f178fc54bafd2">DEBUG_PROFILE_EXIT(argv[0])</a>;</p>
<p>// Handle exit status properly - child may have exited or been signaled if (WIFEXITED(status)) { return WEXITSTATUS(status); } else if (WIFSIGNALED(status)) { // Child was killed by signal - return 128 + signal number (bash // convention) return 128 + WTERMSIG(status); } return 1; } }</p>
<p>/* Forward declaration for test builtin */ static int execute_test_builtin(executor_t *executor, char **argv);</p>
<p>/**</p>
<p>Execute a builtin command</p>
<p>Looks up and executes a shell builtin command from the builtins table. Handles command tracing (set -x) and sets global executor for job control.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">argv</td><td>NULL-terminated argument vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exit status of builtin command */ static int <a class="el" href="#a59d52807b3517f3dad4f4b4036c7a8da">execute_builtin_command(executor_t *executor, char **argv)</a> { if (!argv || !argv[0]) { return 1; }</dd></dl>
<p>// Set global executor for job control builtins current_executor = executor;</p>
<p>// Find the builtin function in the builtin table for (size_t i = 0; i &lt; builtins_count; i++) { if (strcmp(argv[0], builtins[i].name) == 0) { // Print trace for builtin command if -x is enabled if (<a class="el" href="posix__opts_8c.html#a229813ff81324b97887ad109b8d1b322">should_trace_execution()</a>) { // Build command string from argv for tracing size_t cmd_len = 1; // for null terminator for (int j = 0; argv[j]; j++) { cmd_len += strlen(argv[j]) + (j &gt; 0 ? 1 : 0); // +1 for space }</p>
<p>char *cmd_str = malloc(cmd_len); if (cmd_str) { strcpy(cmd_str, argv[0]); for (int j = 1; argv[j]; j++) { strcat(cmd_str, " "); strcat(cmd_str, argv[j]); } print_command_trace(cmd_str); free(cmd_str); } }</p>
<p>// Count arguments int argc = 0; while (argv[argc]) { argc++; }</p>
<p>int result = builtins[i].func(argc, argv);</p>
<p>// Clear global executor current_executor = NULL;</p>
<p>return result; } }</p>
<p>// Clear global executor current_executor = NULL;</p>
<p>return 1; // Command not found }</p>
<p>/**</p>
<p>Check if command name is a builtin</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>Command name to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if command is a shell builtin */ static bool <a class="el" href="#ace283bf4be85f4b662474c8f96d10bc6">is_builtin_command(const char *cmd)</a> { return is_builtin(cmd); }</dd></dl>
<p>/**</p>
<p>Execute the test/[ builtin command</p>
<p>Evaluates test expressions for conditionals. Supports:</p><ul>
<li>Unary operators: -z, -n (string tests)</li>
<li>Binary operators: =, !=, -eq, -ne, -lt, -le, -gt, -ge</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context (reserved for future use) </td></tr>
    <tr><td class="paramname">argv</td><td>NULL-terminated argument vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if test succeeds, 1 if test fails */ MAYBE_UNUSED static int execute_test_builtin(executor_t &lt;em&gt;executor, char **argv) { (void)executor; / Reserved for executor-aware test evaluation */ if (!argv || !argv[0]) { return 1; }</dd></dl>
<p>// Count arguments int argc = 0; while (argv[argc]) { argc++; }</p>
<p>// Handle [ command - must end with ] if (strcmp(argv[0], "[") == 0) { if (argc &lt; 2 || strcmp(argv[argc - 1], "]") != 0) { return 1; // Missing closing ] } argc&ndash;; // Don't count the closing ] }</p>
<p>// Handle different test cases if (argc == 1) { // test with no arguments - false return 1; }</p>
<p>if (argc == 2) { // test STRING - true if STRING is non-empty return (argv[1] &amp;&amp; strlen(argv[1]) &gt; 0) ? 0 : 1; }</p>
<p>if (argc == 3) { // Unary operators if (strcmp(argv[1], "-z") == 0) { // -z STRING - true if STRING is empty return (argv[2] &amp;&amp; strlen(argv[2]) == 0) ? 0 : 1; } if (strcmp(argv[1], "-n") == 0) { // -n STRING - true if STRING is non-empty return (argv[2] &amp;&amp; strlen(argv[2]) &gt; 0) ? 0 : 1; } // Add more unary operators as needed return 1; }</p>
<p>if (argc == 4) { // Binary operators: STRING1 OP STRING2 char *str1 = argv[1]; char *op = argv[2]; char *str2 = argv[3];</p>
<p>if (strcmp(op, "=") == 0 || strcmp(op, "==") == 0) { // String equality return strcmp(str1, str2) == 0 ? 0 : 1; }</p>
<p>if (strcmp(op, "!=") == 0) { // String inequality return strcmp(str1, str2) != 0 ? 0 : 1; }</p>
<p>if (strcmp(op, "-eq") == 0) { // Numeric equality int num1 = atoi(str1); int num2 = atoi(str2); return (num1 == num2) ? 0 : 1; }</p>
<p>if (strcmp(op, "-ne") == 0) { // Numeric inequality int num1 = atoi(str1); int num2 = atoi(str2); return (num1 != num2) ? 0 : 1; }</p>
<p>if (strcmp(op, "-lt") == 0) { // Numeric less than int num1 = atoi(str1); int num2 = atoi(str2); return (num1 &lt; num2) ? 0 : 1; }</p>
<p>if (strcmp(op, "-le") == 0) { // Numeric less than or equal int num1 = atoi(str1); int num2 = atoi(str2); return (num1 &lt;= num2) ? 0 : 1; }</p>
<p>if (strcmp(op, "-gt") == 0) { // Numeric greater than int num1 = atoi(str1); int num2 = atoi(str2); return (num1 &gt; num2) ? 0 : 1; }</p>
<p>if (strcmp(op, "-ge") == 0) { // Numeric greater than or equal int num1 = atoi(str1); int num2 = atoi(str2); return (num1 &gt;= num2) ? 0 : 1; } }</p>
<p>// Default: false return 1; }</p>
<p>/**</p>
<p>Check if text is a variable assignment</p>
<p>An assignment has the form VAR=value with = not at the start. Parameter expansions ${...} are not treated as assignments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>Text to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if text is an assignment */ static bool <a class="el" href="#a3b6e605d61c1af767a519410f61f85dc">is_assignment(const char *text)</a> { if (!text) { return false; }</dd></dl>
<p>// Don't treat parameter expansion ${...} as assignment if (text[0] == '$' &amp;&amp; text[1] == '{') { return false; }</p>
<p>// Look for '=' not at the beginning const char *eq = strchr(text, '='); return eq &amp;&amp; eq != text; }</p>
<p>/**</p>
<p>Execute a variable assignment</p>
<p>Parses and executes VAR=value assignments. Handles:</p><ul>
<li>Variable name validation</li>
<li>Value expansion</li>
<li>Local vs global scope based on context</li>
<li>Auto-export with set -a</li>
<li>Privileged mode restrictions</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">assignment</td><td>Assignment string (VAR=value) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, 1 on failure */ static int <a class="el" href="#aa0b9870b4ce2412b4a9e456741916790">execute_assignment(executor_t *executor, const char *assignment)</a> { if (!executor || !assignment) { return 1; }</dd></dl>
<p>char *eq = strchr(assignment, '='); if (!eq) { return 1; }</p>
<p>// Split into variable and value size_t var_len = eq - assignment; char *var_name = malloc(var_len + 1); if (!var_name) { return 1; }</p>
<p>strncpy(var_name, assignment, var_len); var_name[var_len] = '\0';</p>
<p>// Privileged mode security check for environment variable modifications if (!is_privileged_path_modification_allowed(var_name)) { fprintf(stderr, "lusush: %s: cannot modify restricted variable in privileged " "mode\n", var_name); free(var_name); return 1; }</p>
<p>// Validate variable name if (!var_name[0] || (!isalpha(var_name[0]) &amp;&amp; var_name[0] != '_')) { free(var_name); return 1; }</p>
<p>for (size_t i = 1; i &lt; var_len; i++) { if (!isalnum(var_name[i]) &amp;&amp; var_name[i] != '_') { free(var_name); return 1; } }</p>
<p>// Expand the value using modern expansion char *value = expand_if_needed(executor, eq + 1);</p>
<p>// POSIX compliance: assignments inside functions should be local by default int result; if (symtable_current_level(executor-&gt;symtable) &gt; 0) { // Inside function - use local scope result = symtable_set_local_var(executor-&gt;symtable, var_name, value ? value : ""); } else { // Global scope - use global variable result = symtable_set_global_var(executor-&gt;symtable, var_name, value ? value : "");</p>
<p>// POSIX -a (allexport): automatically export assigned variables if (result == 0 &amp;&amp; <a class="el" href="posix__opts_8c.html#af2135d02a523ce1848215cbd524e96e9">should_auto_export()</a>) { symtable_export_global(var_name); } }</p>
<p>if (executor-&gt;debug) { printf("DEBUG: Assignment %s=%s (result: %d)\n", var_name, value ? value : "", result); }</p>
<p>free(var_name); free(value);</p>
<p>return result == 0 ? 0 : 1; }</p>
<p>/**</p>
<p>Execute a case statement</p>
<p>Matches test word against patterns and executes corresponding commands. Patterns can be separated by | for alternation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">node</td><td>Case statement node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exit status of executed commands, or 0 if no match */ static int <a class="el" href="#a31069b392c236239b782e95047fea273">execute_case(executor_t *executor, node_t *node)</a> { if (!executor || !node || node-&gt;type != NODE_CASE) { return 1; }</dd></dl>
<p>// Get the test word and expand variables in it char *test_word = expand_if_needed(executor, node-&gt;val.str); if (!test_word) { return 1; }</p>
<p>int result = 0; bool matched = false;</p>
<p>// Iterate through case items (children) <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *case_item = node-&gt;first_child; while (case_item &amp;&amp; !matched) { // The pattern is stored in case_item-&gt;val.str char *patterns = case_item-&gt;val.str; if (!patterns) { case_item = case_item-&gt;next_sibling; continue; }</p>
<p>// Split patterns by | and test each one char *pattern_copy = strdup(patterns); if (!pattern_copy) { free(test_word); return 1; }</p>
<p>char *pattern = strtok(pattern_copy, "|"); while (pattern &amp;&amp; !matched) { // Expand variables in pattern char *expanded_pattern = expand_if_needed(executor, pattern); if (expanded_pattern) { if (match_pattern(test_word, expanded_pattern)) { matched = true;</p>
<p>// Execute commands for this case item <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *commands = case_item-&gt;first_child; while (commands) { result = execute_node(executor, commands); if (result != 0) { break; } commands = commands-&gt;next_sibling; } } free(expanded_pattern); } pattern = strtok(NULL, "|"); }</p>
<p>free(pattern_copy); case_item = case_item-&gt;next_sibling; }</p>
<p>free(test_word); return result; }</p>
<p>/**</p>
<p>Execute a function definition</p>
<p>Stores function name and body in the executor's function table. Supports optional parameter syntax (disabled in POSIX mode).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">node</td><td>Function definition node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, 1 on failure */ static int <a class="el" href="#a11762008e135435d99006aa3b751ebdc">execute_function_definition(executor_t *executor, node_t *node)</a> { if (!executor || !node || node-&gt;type != NODE_FUNCTION) { return 1; }</dd></dl>
<p>char *function_name = node-&gt;val.str; if (!function_name) { set_executor_error(executor, "Function definition missing name"); return 1; }</p>
<p>// Get function body (can be NULL for empty function bodies) <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *body = node-&gt;first_child;</p>
<p>// Extract parameter information from function name if encoded <a class="el" href="executor_8h.html#ac0f6db05e3be0c03ea208716041861d1">function_param_t</a> *params = NULL; int param_count = 0; char *actual_function_name = function_name;</p>
<p>// Check if function name contains parameter encoding // POSIX compliance: disable advanced parameter syntax in strict POSIX mode char *param_separator = strchr(function_name, '|'); if (param_separator &amp;&amp; !is_posix_mode_enabled()) { // Extract actual function name size_t name_len = param_separator - function_name; actual_function_name = malloc(name_len + 1); strncpy(actual_function_name, function_name, name_len); actual_function_name[name_len] = '\0';</p>
<p>// Parse parameter information char *param_info = param_separator + 1; if (strncmp(param_info, "PARAMS{", 7) == 0) { char *param_list = param_info + 7; char *end_brace = strchr(param_list, '}'); if (end_brace) { *end_brace = '\0'; // Temporarily null-terminate</p>
<p>// Parse parameter list char *param_copy = strdup(param_list); char *token = strtok(param_copy, ","); <a class="el" href="executor_8h.html#ac0f6db05e3be0c03ea208716041861d1">function_param_t</a> *last_param = NULL;</p>
<p>while (token) { char *equals = strchr(token, '='); char *param_name = token; char *default_value = NULL;</p>
<p>if (equals) { *equals = '\0'; default_value = equals + 1; }</p>
<p><a class="el" href="executor_8h.html#ac0f6db05e3be0c03ea208716041861d1">function_param_t</a> *param = create_function_param(param_name, default_value); if (param) { if (!params) { params = param; } else { last_param-&gt;next = param; } last_param = param; param_count++; }</p>
<p>token = strtok(NULL, ","); }</p>
<p>free(param_copy); *end_brace = '}'; // Restore original string } } }</p>
<p>// Store function in function table if (store_function(executor, actual_function_name, body, params,
                       param_count) != 0) { set_executor_error(executor, "Failed to define function"); if (actual_function_name != function_name) { free(actual_function_name); } return 1; }</p>
<p>if (executor-&gt;debug) { printf("DEBUG: Defined function '%s' with %d parameters\n", actual_function_name, param_count); }</p>
<p>// Clean up allocated function name if we created one if (actual_function_name != function_name) { free(actual_function_name); }</p>
<p>return 0; }</p>
<p>/**</p>
<p>Check if a function is defined</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">function_name</td><td>Name of function to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if function exists in function table */ static bool <a class="el" href="#afdc21ec4aead52dbc2e25cc6d3de5cc8">is_function_defined(executor_t *executor,
                                const char *function_name)</a> { return find_function(executor, function_name) != NULL; }</dd></dl>
<p>/**</p>
<p>Execute a function call</p>
<p>Creates a function scope, sets up positional parameters, executes the function body, and handles return values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">function_name</td><td>Name of function to call </td></tr>
    <tr><td class="paramname">argv</td><td>Argument vector (argv[0] is function name) </td></tr>
    <tr><td class="paramname">argc</td><td>Argument count </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exit status of function body */ static int <a class="el" href="#a7ef8919127781d872d5d1be6330acda6">execute_function_call(executor_t *executor,
                                 const char *function_name, char **argv,
                                 int argc)</a> { if (!executor || !function_name) { return 1; }</dd></dl>
<p><a class="el" href="executor_8h.html#a4ff86c222eadffcfcce6f45bbe194029">function_def_t</a> *func = find_function(executor, function_name); if (!func) { set_executor_error(executor, "Function not found"); return 1; }</p>
<p>// Validate function parameters if (validate_function_parameters(func, argv, argc) != 0) { set_executor_error(executor, "Function parameter validation failed"); return 1; }</p>
<p>if (executor-&gt;debug) { printf("DEBUG: Calling function '%s' with %d args\n", function_name, argc - 1); }</p>
<p>// Create new scope for function if (symtable_push_scope(executor-&gt;symtable, SCOPE_FUNCTION, function_name) != 0) { set_executor_error(executor, "Failed to create function scope"); return 1; }</p>
<p>// Set parameters (both positional and named) if (func-&gt;params) { // Set named parameters with defaults int arg_index = 1; // Skip function name at argv[0] <a class="el" href="executor_8h.html#ac0f6db05e3be0c03ea208716041861d1">function_param_t</a> *param = func-&gt;params;</p>
<p>while (param) { const char *value; if (arg_index &lt; argc) { // Use provided argument value = argv[arg_index++]; } else { // Use default value (already validated that required params are // present) value = param-&gt;default_value ? param-&gt;default_value : ""; }</p>
<p>// Set named parameter if (symtable_set_local_var(executor-&gt;symtable, param-&gt;name, value) != 0) { symtable_pop_scope(executor-&gt;symtable); set_executor_error(executor, "Failed to set function parameter"); return 1; } param = param-&gt;next; } }</p>
<p>// Set positional parameters ($1, $2, etc.) for backward compatibility for (int i = 1; i &lt; argc; i++) { char param_name[16]; snprintf(param_name, sizeof(param_name), "%d", i); if (symtable_set_local_var(executor-&gt;symtable, param_name, argv[i]) != 0) { symtable_pop_scope(executor-&gt;symtable); set_executor_error(executor, "Failed to set function parameter"); return 1; } }</p>
<p>// Set $# (argument count) char argc_str[16]; snprintf(argc_str, sizeof(argc_str), "%d", argc - 1); symtable_set_local_var(executor-&gt;symtable, "#", argc_str);</p>
<p>// No need to clear environment variables with new approach</p>
<p>// Execute function body (handle multiple commands) int result = 0; <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *command = func-&gt;body; while (command) { result = execute_node(executor, command);</p>
<p>// Check if this is a function return (special code 200-255) if (result &gt;= 200 &amp;&amp; result &lt;= 255) { // Extract the actual return value from the special code int actual_return = result - 200;</p>
<p>// Restore previous scope before returning symtable_pop_scope(executor-&gt;symtable);</p>
<p>return actual_return; }</p>
<p>if (result != 0) { break; // Stop on first error } command = command-&gt;next_sibling; }</p>
<p>// Restore previous scope symtable_pop_scope(executor-&gt;symtable);</p>
<p>return result; }</p>
<p>/**</p>
<p>Create a new function parameter</p>
<p>Allocates and initializes a function parameter structure. Parameters without default values are marked as required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Parameter name </td></tr>
    <tr><td class="paramname">default_value</td><td>Default value (NULL for required parameters) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New parameter structure, or NULL on failure */ <a class="el" href="executor_8h.html#ac0f6db05e3be0c03ea208716041861d1">function_param_t</a> *create_function_param(const char *name, const char *default_value) { if (!name) { return NULL; }</dd></dl>
<p><a class="el" href="executor_8h.html#ac0f6db05e3be0c03ea208716041861d1">function_param_t</a> *param = malloc(sizeof(function_param_t)); if (!param) { return NULL; }</p>
<p>param-&gt;name = strdup(name); if (!param-&gt;name) { free(param); return NULL; }</p>
<p>param-&gt;default_value = default_value ? strdup(default_value) : NULL; param-&gt;is_required = (default_value == NULL); param-&gt;next = NULL;</p>
<p>return param; }</p>
<p>/**</p>
<p>Free a function parameter list</p>
<p>Frees all parameters in the linked list including their name and default_value strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>Head of parameter list to free */ void <a class="el" href="executor_8h.html#aa73660c07f00d9a61894cfd7b34b00f2" title="Free a function parameter list.">free_function_params(function_param_t *params)</a> { while (params) { <a class="el" href="executor_8h.html#ac0f6db05e3be0c03ea208716041861d1">function_param_t</a> *next = params-&gt;next; free(params-&gt;name); free(params-&gt;default_value); free(params); params = next; } }</td></tr>
  </table>
  </dd>
</dl>
<p>/**</p>
<p>Validate function call arguments against parameters</p>
<p>Checks that required parameters have values and that the argument count doesn't exceed the parameter count. Disabled in POSIX mode for backward compatibility.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function definition with parameter info </td></tr>
    <tr><td class="paramname">argv</td><td>Argument vector (reserved for future validation) </td></tr>
    <tr><td class="paramname">argc</td><td>Argument count (reserved for arity checking) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, 1 on validation failure */ static int validate_function_parameters(function_def_t &lt;em&gt;func, char **argv,
                                        int argc) { (void)argv; / Reserved for argument type validation */ (void)argc; /* Reserved for arity checking */ if (!func) { return 1; }</dd></dl>
<p>// POSIX compliance: disable parameter validation in strict POSIX mode if (<a class="el" href="#a1595c3f36f971bc24bbff109fc3fd551">is_posix_mode_enabled()</a>) { return 0; }</p>
<p>// If no parameters defined, allow any arguments (backward compatibility) if (!func-&gt;params) { return 0; }</p>
<p>int arg_index = 1; // Skip function name at argv[0] <a class="el" href="executor_8h.html#ac0f6db05e3be0c03ea208716041861d1">function_param_t</a> *param = func-&gt;params;</p>
<p>while (param) { if (arg_index &lt; argc) { // Argument provided for this parameter arg_index++; } else if (param-&gt;is_required) { // Required parameter missing fprintf(stderr, "Error: Function '%s' requires parameter '%s'\n", func-&gt;name, param-&gt;name); return 1; } // Optional parameter without argument - will use default param = param-&gt;next; }</p>
<p>// Check for too many arguments if (arg_index &lt; argc) { fprintf(stderr, "Error: Function '%s' called with %d arguments but only " "accepts %d\n", func-&gt;name, argc - 1, func-&gt;param_count); return 1; }</p>
<p>return 0; }</p>
<p>/**</p>
<p>Find function in function table</p>
<p>Searches the executor's function linked list for a function with the specified name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">function_name</td><td>Name to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Function definition, or NULL if not found */ static <a class="el" href="executor_8h.html#a4ff86c222eadffcfcce6f45bbe194029">function_def_t</a> *find_function(<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *executor, const char *function_name) { if (!executor || !function_name) { return NULL; }</dd></dl>
<p><a class="el" href="executor_8h.html#a4ff86c222eadffcfcce6f45bbe194029">function_def_t</a> *func = executor-&gt;functions; while (func) { if (strcmp(func-&gt;name, function_name) == 0) { return func; } func = func-&gt;next; } return NULL; }</p>
<p>/**</p>
<p>Store function in function table</p>
<p>Stores or replaces a function definition. Creates a deep copy of the function body AST. If a function with the same name exists, it is replaced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">function_name</td><td>Function name </td></tr>
    <tr><td class="paramname">body</td><td>AST of function body (will be copied) </td></tr>
    <tr><td class="paramname">params</td><td>Parameter list (ownership transferred) </td></tr>
    <tr><td class="paramname">param_count</td><td>Number of parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, 1 on failure */ static int <a class="el" href="#a50d296cbbc773a18f0ec69d88383f655">store_function(executor_t *executor, const char *function_name,
                          node_t *body, function_param_t *params,
                          int param_count)</a> { if (!executor || !function_name) { return 1; }</dd></dl>
<p>// Check if function already exists and remove it <a class="el" href="executor_8h.html#a4ff86c222eadffcfcce6f45bbe194029">function_def_t</a> **current = &amp;executor-&gt;functions; while (*current) { if (strcmp((*current)-&gt;name, function_name) == 0) { <a class="el" href="executor_8h.html#a4ff86c222eadffcfcce6f45bbe194029">function_def_t</a> *to_remove = *current; *current = (*current)-&gt;next; free(to_remove-&gt;name); free_node_tree(to_remove-&gt;body); free_function_params(to_remove-&gt;params); free(to_remove); break; } current = &amp;(*current)-&gt;next; }</p>
<p>// Create new function definition <a class="el" href="executor_8h.html#a4ff86c222eadffcfcce6f45bbe194029">function_def_t</a> *new_func = malloc(sizeof(function_def_t)); if (!new_func) { return 1; }</p>
<p>new_func-&gt;name = strdup(function_name); if (!new_func-&gt;name) { free(new_func); return 1; }</p>
<p>// Create a deep copy of the body AST (including sibling chain) // Allow NULL bodies for empty functions new_func-&gt;body = copy_ast_chain(body); if (!new_func-&gt;body &amp;&amp; body != NULL) { // Only fail if body was non-NULL but copy failed free(new_func-&gt;name); free(new_func); return 1; }</p>
<p>// Store parameter information new_func-&gt;params = params; new_func-&gt;param_count = param_count;</p>
<p>// Add to front of function list new_func-&gt;next = executor-&gt;functions; executor-&gt;functions = new_func;</p>
<p>return 0; }</p>
<p>/**</p>
<p>Copy an AST node recursively</p>
<p>Creates a deep copy of an AST node including all children. Does not copy siblings - use copy_ast_chain for that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Deep copy of node, or NULL on failure */ static <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *copy_ast_node(<a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *node) { if (!node) { return NULL; }</dd></dl>
<p><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *copy = new_node(node-&gt;type); if (!copy) { return NULL; }</p>
<p>// Copy value copy-&gt;val_type = node-&gt;val_type; if (node-&gt;val.str) { copy-&gt;val.str = strdup(node-&gt;val.str); if (!copy-&gt;val.str) { free_node_tree(copy); return NULL; } } else { copy-&gt;val = node-&gt;val; }</p>
<p>// Copy children <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *child = node-&gt;first_child; while (child) { <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *child_copy = copy_ast_node(child); if (!child_copy) { free_node_tree(copy); return NULL; } add_child_node(copy, child_copy); child = child-&gt;next_sibling; }</p>
<p>return copy; }</p>
<p>/**</p>
<p>Copy an AST node chain including siblings</p>
<p>Creates a deep copy of a node and all its siblings. Used for copying function bodies with multiple statements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>First node in chain to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Deep copy of entire chain, or NULL on failure */ static <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *copy_ast_chain(<a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *node) { if (!node) { return NULL; }</dd></dl>
<p><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *first_copy = copy_ast_node(node); if (!first_copy) { return NULL; }</p>
<p><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *current_copy = first_copy; <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *current_orig = node-&gt;next_sibling;</p>
<p>while (current_orig) { <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *sibling_copy = copy_ast_node(current_orig); if (!sibling_copy) { free_node_tree(first_copy); return NULL; }</p>
<p>current_copy-&gt;next_sibling = sibling_copy; sibling_copy-&gt;prev_sibling = current_copy;</p>
<p>current_copy = sibling_copy; current_orig = current_orig-&gt;next_sibling; }</p>
<p>return first_copy; }</p>
<p>/**</p>
<p>Check if a string is empty or NULL</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if str is NULL or empty string */ static bool is_empty_or_null(const char *str) { return !str || str[0] == '\0'; }</dd></dl>
<p>/**</p>
<p>Extract a substring with offset and length</p>
<p>Supports negative offsets (from end of string). Handles bounds checking and returns empty string for invalid ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Source string </td></tr>
    <tr><td class="paramname">offset</td><td>Starting position (negative for from-end) </td></tr>
    <tr><td class="paramname">length</td><td>Number of characters (-1 for rest of string) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Extracted substring (caller must free) */ static char *extract_substring(const char *str, int offset, int length) { if (!str) { return strdup(""); }</dd></dl>
<p>int str_len = strlen(str);</p>
<p>// Handle negative offset (from end) if (offset &lt; 0) { offset = str_len + offset; if (offset &lt; 0) { offset = 0; } }</p>
<p>// Bounds check if (offset &gt;= str_len) { return strdup(""); }</p>
<p>// Calculate actual length int remaining = str_len - offset; if (length &lt; 0 || length &gt; remaining) { length = remaining; }</p>
<p>char *result = malloc(length + 1); if (!result) { return strdup(""); }</p>
<p>strncpy(result, str + offset, length); result[length] = '\0';</p>
<p>return result; }</p>
<p>/**</p>
<p>Match string against glob pattern</p>
<p>Supports *, ?, and [...] character classes including ranges and negation [!...] or [^...]. Used for case patterns and parameter expansion pattern matching.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to match </td></tr>
    <tr><td class="paramname">pattern</td><td>Glob pattern </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if string matches pattern */ static bool <a class="el" href="#a00f062e9edf50854864902595dbb91f0">match_pattern(const char *str, const char *pattern)</a> { if (!str || !pattern) { return false; }</dd></dl>
<p>const char *s = str; const char *p = pattern;</p>
<p>while (<em>p) { if (*p == '</em>') { // Handle wildcard p++; // Skip the *</p>
<p>// If * is at the end, it matches everything remaining if (*p == '\0') { return true; }</p>
<p>// Try to match the rest of the pattern at each position in the // string while (*s) { if (match_pattern(s, p)) { return true; } s++; }</p>
<p>// Try matching the pattern with empty string (for cases like // "*suffix") return match_pattern(s, p); } else if (*p == '?') { // Wildcard matches any single character if (*s == '\0') { return false; // ? can't match empty } s++; p++; } else if (*p == '[') { // Character class pattern [abc] or [a-z] if (*s == '\0') { return false; // Character class can't match empty }</p>
<p>p++; // Skip opening [ bool matched = false; bool negated = false;</p>
<p>// Check for negation [!abc] or [^abc] if (*p == '!' || *p == '^') { negated = true; p++; }</p>
<p>while (*p &amp;&amp; *p != ']') { if (p[1] == '-' &amp;&amp; p[2] != ']' &amp;&amp; p[2] != '\0') { // Range pattern like a-z if (*s &gt;= *p &amp;&amp; *s &lt;= p[2]) { matched = true; } p += 3; // Skip a-z } else { // Single character if (*s == *p) { matched = true; } p++; } }</p>
<p>if (*p == ']') { p++; // Skip closing ] }</p>
<p>// Apply negation if needed if (negated) { matched = !matched; }</p>
<p>if (!matched) { return false; }</p>
<p>s++; } else { // Literal character match (including special chars like : @ / etc.) if (*s != *p) { return false; } s++; p++; } }</p>
<p>// Pattern is exhausted, string should be too for a complete match return *s == '\0'; }</p>
<p>/**</p>
<p>Find prefix match length for # and ## operators</p>
<p>Finds how many characters from the beginning of str match pattern. Used for ${var#pattern} and ${var##pattern} expansion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to search </td></tr>
    <tr><td class="paramname">pattern</td><td>Pattern to match </td></tr>
    <tr><td class="paramname">longest</td><td>If true, find longest match (##), else shortest (#) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of characters matched from beginning */ static int find_prefix_match(const char *str, const char *pattern,
                             bool longest) { if (!str || !pattern) { return 0; }</dd></dl>
<p>int str_len = strlen(str); int match_len = 0;</p>
<p>for (int i = 0; i &lt;= str_len; i++) { char *substr = malloc(i + 1); if (!substr) { break; }</p>
<p>strncpy(substr, str, i); substr[i] = '\0';</p>
<p>if (match_pattern(substr, pattern)) { match_len = i; if (!longest) { free(substr); break; // Return first (shortest) match } } free(substr); }</p>
<p>return match_len; }</p>
<p>/**</p>
<p>Find suffix match length for % and %% operators</p>
<p>Finds how many characters from the end of str match pattern. Used for ${varpattern} and ${var%pattern} expansion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to search </td></tr>
    <tr><td class="paramname">pattern</td><td>Pattern to match </td></tr>
    <tr><td class="paramname">longest</td><td>If true, find longest match (%%), else shortest (%) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of characters matched from end */ static int find_suffix_match(const char *str, const char *pattern,
                             bool longest) { if (!str || !pattern) { return 0; }</dd></dl>
<p>int str_len = strlen(str); int match_len = 0;</p>
<p>for (int i = 0; i &lt;= str_len; i++) { const char *suffix = str + str_len - i; if (match_pattern(suffix, pattern)) { match_len = i; if (!longest) { break; // Return first (shortest) match } } }</p>
<p>return match_len; }</p>
<p>/**</p>
<p>Convert first character to uppercase</p>
<p>Used for ${var^} parameter expansion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted string (caller must free) */ static char *convert_case_first_upper(const char *str) { if (!str) { return strdup(""); }</dd></dl>
<p>size_t len = strlen(str); char *result = malloc(len + 1); if (!result) { return strdup(""); }</p>
<p>strcpy(result, str); if (len &gt; 0 &amp;&amp; islower(result[0])) { result[0] = toupper(result[0]); }</p>
<p>return result; }</p>
<p>/**</p>
<p>Convert first character to lowercase</p>
<p>Used for ${var,} parameter expansion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted string (caller must free) */ static char *convert_case_first_lower(const char *str) { if (!str) { return strdup(""); }</dd></dl>
<p>size_t len = strlen(str); char *result = malloc(len + 1); if (!result) { return strdup(""); }</p>
<p>strcpy(result, str); if (len &gt; 0 &amp;&amp; isupper(result[0])) { result[0] = tolower(result[0]); }</p>
<p>return result; }</p>
<p>/**</p>
<p>Convert all characters to uppercase</p>
<p>Used for ${var^^} parameter expansion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted string (caller must free) */ static char *convert_case_all_upper(const char *str) { if (!str) { return strdup(""); }</dd></dl>
<p>size_t len = strlen(str); char *result = malloc(len + 1); if (!result) { return strdup(""); }</p>
<p>for (size_t i = 0; i &lt; len; i++) { result[i] = toupper(str[i]); } result[len] = '\0';</p>
<p>return result; }</p>
<p>/**</p>
<p>Convert all characters to lowercase</p>
<p>Used for ${var,,} parameter expansion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted string (caller must free) */ static char *convert_case_all_lower(const char *str) { if (!str) { return strdup(""); }</dd></dl>
<p>size_t len = strlen(str); char *result = malloc(len + 1); if (!result) { return strdup(""); }</p>
<p>for (size_t i = 0; i &lt; len; i++) { result[i] = tolower(str[i]); } result[len] = '\0';</p>
<p>return result; }</p>
<p>/**</p>
<p>Recursively expand variables within a string</p>
<p>Expands all variable references, arithmetic expressions, and command substitutions within a string. Used for expanding default values in parameter expansion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">str</td><td>String containing variables to expand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Fully expanded string (caller must free) */ static char *expand_variables_in_string(<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *executor, const char *str) { if (!str || !executor) { return strdup(""); }</dd></dl>
<p>size_t len = strlen(str); char *result = malloc(len * 2 + 1); // Start with double size if (!result) { return strdup(""); }</p>
<p>size_t result_pos = 0; size_t result_size = len * 2 + 1;</p>
<p>for (size_t i = 0; i &lt; len; i++) { if (str[i] == '$') { // Check for arithmetic expansion $((...) if (i + 2 &lt; len &amp;&amp; str[i + 1] == '(' &amp;&amp; str[i + 2] == '(') { // This is arithmetic expansion $((expr)) size_t arith_start = i; size_t arith_end = i + 3; int paren_depth = 2;</p>
<p>while (arith_end &lt; len &amp;&amp; paren_depth &gt; 0) { if (str[arith_end] == '(') { paren_depth++; } else if (str[arith_end] == ')') { paren_depth&ndash;; } arith_end++; }</p>
<p>if (paren_depth == 0) { // Extract arithmetic expression including $(( and )) size_t full_arith_len = arith_end - arith_start; char *full_arith_expr = malloc(full_arith_len + 1); if (full_arith_expr) { strncpy(full_arith_expr, &amp;str[arith_start],
                                full_arith_len); full_arith_expr[full_arith_len] = '\0';</p>
<p>// Expand arithmetic expression char *arith_result = expand_arithmetic(executor, full_arith_expr); if (arith_result) { size_t result_len = strlen(arith_result);</p>
<p>// Ensure buffer is large enough while (result_pos + result_len &gt;= result_size) { result_size *= 2; char *new_result = realloc(result, result_size); if (!new_result) { free(result); free(arith_result); free(full_arith_expr); return strdup(""); } result = new_result; }</p>
<p>// Copy arithmetic result strcpy(&amp;result[result_pos], arith_result); result_pos += result_len; free(arith_result); } free(full_arith_expr); }</p>
<p>i = arith_end - 1; // Skip past the entire $((...) continue; } } // Check for command substitution $(...) else if (i + 1 &lt; len &amp;&amp; str[i + 1] == '(') { // Find matching closing parenthesis using find_closing_brace char *temp_str = (char *)&amp;str[i + 1]; // Start from the opening parenthesis size_t brace_offset = find_closing_brace(temp_str);</p>
<p>if (brace_offset &gt; 0) { // Extract command from $(...) size_t cmd_len = brace_offset - 1; // Exclude the closing paren char *command = malloc(cmd_len + 1); if (command) { strncpy(command, &amp;str[i + 2], cmd_len); // Skip $( command[cmd_len] = '\0';</p>
<p>// Execute command substitution - need to wrap in $() // format char *wrapped_cmd = malloc(cmd_len + 4); // +3 for $() +1 for null if (wrapped_cmd) { snprintf(wrapped_cmd, cmd_len + 4, "$(%s)", command); char *cmd_result = expand_command_substitution(
                                executor, wrapped_cmd); free(wrapped_cmd); if (cmd_result) { size_t value_len = strlen(cmd_result);</p>
<p>// Ensure buffer is large enough while (result_pos + value_len &gt;= result_size) { result_size *= 2; char *new_result = realloc(result, result_size); if (!new_result) { free(result); free(cmd_result); free(command); return strdup(""); } result = new_result; }</p>
<p>strcpy(&amp;result[result_pos], cmd_result); result_pos += value_len; free(cmd_result); } }</p>
<p>free(command); i = i + 1 + brace_offset; // Skip past the entire $(...) continue; } } }</p>
<p>// Find variable name size_t var_start = i + 1; size_t var_end = var_start;</p>
<p>// Handle ${var} format if (var_start &lt; len &amp;&amp; str[var_start] == '{') { // Use proper brace matching for nested expressions char *brace_str = (char *)&amp;str[var_start]; size_t brace_len = find_closing_brace(brace_str);</p>
<p>if (brace_len &gt; 0) { // brace_len is the index of the closing brace var_end = var_start + brace_len + 1; // Point to after closing brace } else { // Fallback: find closing brace manually with nesting // support int brace_count = 1; var_end = var_start + 1; // Start after opening {</p>
<p>while (var_end &lt; len &amp;&amp; brace_count &gt; 0) { if (str[var_end] == '{') { brace_count++; } else if (str[var_end] == '}') { brace_count&ndash;; } var_end++; } } } else { // Handle $var format while (var_end &lt; len &amp;&amp; (isalnum(str[var_end]) || str[var_end] == '_')) { var_end++; } }</p>
<p>if (var_end &gt; var_start) { // Extract and expand variable size_t var_len = var_end - i; char *var_expr = malloc(var_len + 1); if (var_expr) { strncpy(var_expr, &amp;str[i], var_len); var_expr[var_len] = '\0';</p>
<p>char *var_value = expand_variable(executor, var_expr); if (var_value) { size_t value_len = strlen(var_value);</p>
<p>// Ensure buffer is large enough while (result_pos + value_len &gt;= result_size) { result_size *= 2; char *new_result = realloc(result, result_size); if (!new_result) { free(result); free(var_value); free(var_expr); return strdup(""); } result = new_result; }</p>
<p>strcpy(&amp;result[result_pos], var_value); result_pos += value_len; free(var_value); }</p>
<p>free(var_expr); i = var_end - 1; // Skip past variable continue; } } }</p>
<p>// Regular character - ensure buffer space if (result_pos + 1 &gt;= result_size) { result_size *= 2; char *new_result = realloc(result, result_size); if (!new_result) { free(result); return strdup(""); } result = new_result; }</p>
<p>result[result_pos++] = str[i]; }</p>
<p>result[result_pos] = '\0'; return result; }</p>
<p>/**</p>
<p>Parse and execute parameter expansion</p>
<p>Handles all POSIX and bash-style parameter expansions:</p><ul>
<li>${#var} - length</li>
<li>${var:-default} - use default if unset/empty</li>
<li>${var:+alternative} - use alternative if set</li>
<li>${var#pattern} - remove shortest prefix</li>
<li>${var##pattern} - remove longest prefix</li>
<li>${varpattern} - remove shortest suffix</li>
<li>${var%pattern} - remove longest suffix</li>
<li>${var^} ${var^^} - case conversion</li>
<li>${var,} ${var,,} - case conversion</li>
<li>${var:offset:length} - substring</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">expansion</td><td>Content inside ${...} (without braces) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Expanded value (caller must free) */ static char *parse_parameter_expansion(<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *executor, const char *expansion) { if (!expansion) { return strdup(""); }</dd></dl>
<p>// Handle length expansion: ${#var} if (expansion[0] == '#') { const char *var_name = expansion + 1; char *value = symtable_get_var(executor-&gt;symtable, var_name); if (value) { int len = strlen(value); char *result = malloc(16); if (result) { snprintf(result, 16, "%d", len); } return result ? result : strdup("0"); } return strdup("0"); }</p>
<p>// Look for parameter expansion operators const char *op_pos = NULL; const char *operators[] = {":-", ":+", "##", "%%", "^^", ",,", "#", "%", "^", ",", "-", "+", ":=", "=", ":", NULL}; int op_type = -1;</p>
<p>// Find the first valid operator - prioritize longer operators first for (int i = 0; operators[i]; i++) { const char *found = strstr(expansion, operators[i]); if (found) { // Skip single-character operators that are part of longer ones if (strlen(operators[i]) == 1) { // Check if this single char is part of a longer operator bool part_of_longer = false;</p>
<p>// Check for :- and :+ before processing single : if (strcmp(operators[i], ":") == 0) { if ((found &gt; expansion &amp;&amp; (found[-1] == '-' || found[-1] == '+')) || (found[1] == '-' || found[1] == '+' || found[1] == '=')) { part_of_longer = true; } }</p>
<p>// Check for ## and %% before processing single # or % if (strcmp(operators[i], "#") == 0 &amp;&amp; found[1] == '#') { part_of_longer = true; } if (strcmp(operators[i], "%") == 0 &amp;&amp; found[1] == '') { part_of_longer = true; }</p>
<p>if (part_of_longer) { continue; } }</p>
<p>// If we haven't found an operator yet, or this one comes first, use // it if (!op_pos || found &lt; op_pos) { op_pos = found; op_type = i; } } }</p>
<p>if (op_pos) { // Extract variable name size_t var_len = op_pos - expansion; char *var_name = malloc(var_len + 1); if (!var_name) { return strdup(""); }</p>
<p>strncpy(var_name, expansion, var_len); var_name[var_len] = '\0';</p>
<p>// Get variable value char *var_value = symtable_get_var(executor-&gt;symtable, var_name); const char *default_value = op_pos + strlen(operators[op_type]);</p>
<p>// Expand variables in default value char *expanded_default = expand_variables_in_string(executor, default_value);</p>
<p>char *result = NULL;</p>
<p>switch (op_type) { case 0: // ${var:-default} - use default if var is unset or empty if (is_empty_or_null(var_value)) { result = strdup(expanded_default); } else { result = strdup(var_value); } break;</p>
<p>case 1: // ${var:+alternative} - use alternative if var is set and // non-empty if (!is_empty_or_null(var_value)) { result = strdup(expanded_default); } else { result = strdup(""); } break;</p>
<p>case 2: // ${var##pattern} - remove longest match of pattern from // beginning if (var_value) { int match_len = find_prefix_match(var_value, expanded_default, true); result = strdup(var_value + match_len); } else { result = strdup(""); } break;</p>
<p>case 3: // ${var%pattern} - remove longest match of pattern from end if (var_value) { int str_len = strlen(var_value); int match_len = find_suffix_match(var_value, expanded_default, true); int result_len = str_len - match_len; result = malloc(result_len + 1); if (result) { strncpy(result, var_value, result_len); result[result_len] = '\0'; } else { result = strdup(""); } } else { result = strdup(""); } break;</p>
<p>case 4: // ${var^^} - convert all characters to uppercase if (var_value) { result = convert_case_all_upper(var_value); } else { result = strdup(""); } break;</p>
<p>case 5: // ${var,,} - convert all characters to lowercase if (var_value) { result = convert_case_all_lower(var_value); } else { result = strdup(""); } break;</p>
<p>case 6: // ${var#pattern} - remove shortest match of pattern from // beginning if (var_value) { int match_len = find_prefix_match(var_value, expanded_default, false); result = strdup(var_value + match_len); } else { result = strdup(""); } break;</p>
<p>case 7: // ${varpattern} - remove shortest match of pattern from end if (var_value) { int str_len = strlen(var_value); int match_len = find_suffix_match(var_value, expanded_default, false); int result_len = str_len - match_len; result = malloc(result_len + 1); if (result) { strncpy(result, var_value, result_len); result[result_len] = '\0'; } else { result = strdup(""); } } else { result = strdup(""); } break;</p>
<p>case 8: // ${var^} - convert first character to uppercase if (var_value) { result = convert_case_first_upper(var_value); } else { result = strdup(""); } break;</p>
<p>case 9: // ${var,} - convert first character to lowercase if (var_value) { result = convert_case_first_lower(var_value); } else { result = strdup(""); } break;</p>
<p>case 10: // ${var-default} - use default if var is unset (but not if // empty) if (!var_value) { result = strdup(expanded_default); } else { result = strdup(var_value); } break;</p>
<p>case 11: // ${var+alternative} - use alternative if var is set (even if // empty) if (var_value) { result = strdup(expanded_default); } else { result = strdup(""); } break;</p>
<p>case 12: // ${var:=default} - assign default if var is unset or empty // and return it if (is_empty_or_null(var_value)) { symtable_set_var(executor-&gt;symtable, var_name, expanded_default, SYMVAR_NONE); result = strdup(expanded_default); } else { result = strdup(var_value); } break;</p>
<p>case 13: // ${var=default} - assign default if var is unset and return // it if (!var_value) { symtable_set_var(executor-&gt;symtable, var_name, expanded_default, SYMVAR_NONE); result = strdup(expanded_default); } else { result = strdup(var_value); } break;</p>
<p>case 14: // ${var:offset:length} - substring expansion if (var_value) { // Parse offset and optional length (with variable expansion) char *expanded_offset_str = expand_variables_in_string(executor, expanded_default); char *endptr; int offset = strtol(expanded_offset_str, &amp;endptr, 10); int length = -1;</p>
<p>if (*endptr == ':') { length = strtol(endptr + 1, NULL, 10); }</p>
<p>result = extract_substring(var_value, offset, length); free(expanded_offset_str); } else { result = strdup(""); } break; }</p>
<p>free(var_name); free(expanded_default); return result ? result : strdup(""); }</p>
<p>// No operator found, just get the variable value // First check for special variables that aren't in the symbol table if (strlen(expansion) == 1) { char buffer[1024];</p>
<p>switch (expansion[0]) { case '?': // Exit status of last command snprintf(buffer, sizeof(buffer), "%d", last_exit_status); return strdup(buffer);</p>
<p>case '$': // Shell process ID snprintf(buffer, sizeof(buffer), "%d", (int)shell_pid); return strdup(buffer);</p>
<p>case '#': // Number of positional parameters snprintf(buffer, sizeof(buffer), "%d", shell_argc &gt; 1 ? shell_argc - 1 : 0); return strdup(buffer);</p>
<p>case '!': // Process ID of last background command if (last_background_pid &gt; 0) { snprintf(buffer, sizeof(buffer), "%d", (int)last_background_pid); return strdup(buffer); } else { return strdup(""); }</p>
<p>case '*': // All positional parameters as single word if (shell_argc &gt; 1) { size_t total_len = 0; for (int i = 1; i &lt; shell_argc; i++) { if (shell_argv[i]) { total_len += strlen(shell_argv[i]) + 1; // +1 for space } } if (total_len &gt; 0) { char *result = malloc(total_len); if (result) { result[0] = '\0'; for (int i = 1; i &lt; shell_argc; i++) { if (shell_argv[i]) { if (i &gt; 1) { strcat(result, " "); } strcat(result, shell_argv[i]); } } return result; } } } return strdup("");</p>
<p>case '@': // All positional parameters as separate words if (shell_argc &gt; 1) { size_t total_len = 0; for (int i = 1; i &lt; shell_argc; i++) { if (shell_argv[i]) { total_len += strlen(shell_argv[i]) + 1; // +1 for space } } if (total_len &gt; 0) { char *result = malloc(total_len); if (result) { result[0] = '\0'; for (int i = 1; i &lt; shell_argc; i++) { if (shell_argv[i]) { if (i &gt; 1) { strcat(result, " "); } strcat(result, shell_argv[i]); } } return result; } } } return strdup("");</p>
<p>default: if (expansion[0] &gt;= '0' &amp;&amp; expansion[0] &lt;= '9') { // Handle positional parameters $0, $1, $2, etc. int pos = expansion[0] - '0';</p>
<p>if (pos == 0) { // $0 is the script/shell name return strdup((shell_argc &gt; 0 &amp;&amp; shell_argv[0]) ? shell_argv[0] : "lusush"); } else if (pos &gt; 0 &amp;&amp; pos &lt; shell_argc &amp;&amp; shell_argv[pos]) { // $1, $2, etc. are script arguments return strdup(shell_argv[pos]); } else { // Parameter doesn't exist, return empty string return strdup(""); } } break; } }</p>
<p>// Fall back to symbol table lookup for regular variables char *value = symtable_get_var(executor-&gt;symtable, expansion);</p>
<p>// Check for unset variable error (set -u) for ${var} syntax if (!value &amp;&amp; shell_opts.unset_error) { // Don't error on special variables that have default behavior if (strlen(expansion) != 1 || (expansion[0] != '?' &amp;&amp; expansion[0] != '$' &amp;&amp; expansion[0] != '#' &amp;&amp; expansion[0] != '0' &amp;&amp; expansion[0] != '@' &amp;&amp; expansion[0] != '*')) { // Set expansion error instead of exiting to allow || constructs executor-&gt;expansion_error = true; executor-&gt;expansion_exit_status = 1; return strdup(""); // Return empty string for unbound variable } }</p>
<p>return value ? strdup(value) : strdup(""); }</p>
<p>/**</p>
<p>Expand a variable reference</p>
<p>Expands $var and ${var...} syntax. Handles special variables:</p><ul>
<li>$? - last exit status</li>
<li>$$ - shell PID</li>
<li>$# - argument count</li>
<li>$*, $@ - positional parameters</li>
<li>$0-$9 - individual positional parameters</li>
<li>$! - last background PID</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">var_text</td><td>Variable text starting with $ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Expanded value (caller must free) */ static char *expand_variable(<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *executor, const char *var_text) { if (!executor || !var_text || var_text[0] != '$') { return strdup(var_text ? var_text : ""); }</dd></dl>
<p>// Special case: if var_text is exactly "$$", treat it as shell PID if (strcmp(var_text, "$$") == 0) { char buffer[32]; snprintf(buffer, sizeof(buffer), "%d", (int)shell_pid); return strdup(buffer); }</p>
<p>// Special case: if var_text is exactly "$", treat it as shell PID if (strcmp(var_text, "$") == 0) { char buffer[32]; snprintf(buffer, sizeof(buffer), "%d", (int)shell_pid); return strdup(buffer); }</p>
<p>// Special case: if var_text is exactly "$?", treat it as exit status if (strcmp(var_text, "$?") == 0) { char buffer[32]; snprintf(buffer, sizeof(buffer), "%d", last_exit_status); return strdup(buffer); }</p>
<p>const char *var_name = var_text + 1;</p>
<p>// Handle ${var} format with advanced parameter expansion if (var_name[0] == '{') { </p><pre class="fragment">char *close = strchr(var_name, '}');
if (close) {
    size_t len = close - var_name - 1;
    char *expansion = malloc(len + 1);
    if (expansion) {
        strncpy(expansion, var_name + 1, len);
        expansion[len] = '\0';

        char *result = parse_parameter_expansion(executor, expansion);

        free(expansion);
        return result;
    }
}
</pre><p> } else { // Simple $var format - handle special variables and regular variables size_t name_len = 0;</p>
<p>// Check for special single-character variables first if (var_name[0] == '?' || var_name[0] == '$' || var_name[0] == '#' || var_name[0] == '*' || var_name[0] == '@' || var_name[0] == '!' || (var_name[0] &gt;= '0' &amp;&amp; var_name[0] &lt;= '9')) { name_len = 1; } else { // Regular variable names (alphanumeric + underscore) while (var_name[name_len] &amp;&amp; (isalnum(var_name[name_len]) || var_name[name_len] == '_')) { name_len++; } }</p>
<p>if (name_len &gt; 0) { char *name = malloc(name_len + 1); if (name) { strncpy(name, var_name, name_len); name[name_len] = '\0';</p>
<p>// Look up in modern symbol table char *value = symtable_get_var(executor-&gt;symtable, name);</p>
<p>// Check for unset variable error (set -u) if (!value &amp;&amp; shell_opts.unset_error &amp;&amp; name_len &gt; 0) { // Don't error on special variables that have default // behavior if (name_len != 1 || (name[0] != '?' &amp;&amp; name[0] != '$' &amp;&amp; name[0] != '#' &amp;&amp; name[0] != '0' &amp;&amp; name[0] != '@' &amp;&amp; name[0] != '*')) { free(name); // Set expansion error instead of exiting to allow || // constructs executor-&gt;expansion_error = true; executor-&gt;expansion_exit_status = 1; return strdup( ""); // Return empty string for unbound variable } }</p>
<p>// If not found in symbol table and it's a special variable, // handle it directly if (!value &amp;&amp; name_len == 1) { char buffer[1024];</p>
<p>switch (name[0]) { case '?': // Exit status of last command snprintf(buffer, sizeof(buffer), "%d", last_exit_status); free(name); return strdup(buffer);</p>
<p>case '$': // Shell process ID snprintf(buffer, sizeof(buffer), "%d", (int)shell_pid); free(name); return strdup(buffer);</p>
<p>case '#': // Number of positional parameters snprintf(buffer, sizeof(buffer), "%d", shell_argc &gt; 1 ? shell_argc - 1 : 0); free(name); return strdup(buffer);</p>
<p>case '!': // Process ID of last background command if (last_background_pid &gt; 0) { snprintf(buffer, sizeof(buffer), "%d", (int)last_background_pid); free(name); return strdup(buffer); } else { free(name); return strdup(""); }</p>
<p>case '*': // All positional parameters as single word { // Check if we're in function scope - try to get $# from // local scope char *func_argc_str = symtable_get_var(executor-&gt;symtable, "#"); if (func_argc_str &amp;&amp; executor-&gt;symtable) { // We're in a function scope - use function // parameters int func_argc = atoi(func_argc_str); if (func_argc &gt; 0) { size_t total_len = 0; // Calculate total length needed for (int i = 1; i &lt;= func_argc; i++) { char param_name[16]; snprintf(param_name, sizeof(param_name), "%d", i); char *param_value = symtable_get_var( executor-&gt;symtable, param_name); if (param_value) { total_len += strlen(param_value) + 1; // +1 for space } } if (total_len &gt; 0) { char *result = malloc(total_len); if (result) { result[0] = '\0'; for (int i = 1; i &lt;= func_argc; i++) { char param_name[16]; snprintf(param_name, sizeof(param_name), "%d", i); char *param_value = symtable_get_var( executor-&gt;symtable, param_name); if (param_value) { if (i &gt; 1) { strcat(result, " "); } strcat(result, param_value); } } free(name); return result; } } } free(name); return strdup(""); } else { // Use global shell parameters if (shell_argc &gt; 1) { size_t total_len = 0; for (int i = 1; i &lt; shell_argc; i++) { if (shell_argv[i]) { total_len += strlen(shell_argv[i]) + 1; // +1 for space } } if (total_len &gt; 0) { char *result = malloc(total_len); if (result) { result[0] = '\0'; for (int i = 1; i &lt; shell_argc; i++) { if (shell_argv[i]) { if (i &gt; 1) { strcat(result, " "); } strcat(result, shell_argv[i]); } } free(name); return result; } } } free(name); return strdup(""); } }</p>
<p>case '@': // All positional parameters as separate words { // Check if we're in function scope - try to get $# from // local scope char *func_argc_str = symtable_get_var(executor-&gt;symtable, "#"); if (func_argc_str &amp;&amp; executor-&gt;symtable) { // We're in a function scope - use function // parameters int func_argc = atoi(func_argc_str); if (func_argc &gt; 0) { size_t total_len = 0; // Calculate total length needed for (int i = 1; i &lt;= func_argc; i++) { char param_name[16]; snprintf(param_name, sizeof(param_name), "%d", i); char *param_value = symtable_get_var( executor-&gt;symtable, param_name); if (param_value) { total_len += strlen(param_value) + 1; // +1 for space } } if (total_len &gt; 0) { char *result = malloc(total_len); if (result) { result[0] = '\0'; for (int i = 1; i &lt;= func_argc; i++) { char param_name[16]; snprintf(param_name, sizeof(param_name), "%d", i); char <em>param_value = symtable_get_var( executor-&gt;symtable, param_name); if (param_value) { if (i &gt; 1) { strcat(result, " "); } strcat(result, param_value); } } free(name); return result; } } } free(name); return strdup(""); } else { // Use global shell parameters // Note: This should ideally preserve word // boundaries, but for now we'll implement it // similarly to $</em> for compatibility if (shell_argc &gt; 1) { size_t total_len = 0; for (int i = 1; i &lt; shell_argc; i++) { if (shell_argv[i]) { total_len += strlen(shell_argv[i]) + 1; // +1 for space } } if (total_len &gt; 0) { char *result = malloc(total_len); if (result) { result[0] = '\0'; for (int i = 1; i &lt; shell_argc; i++) { if (shell_argv[i]) { if (i &gt; 1) { strcat(result, " "); } strcat(result, shell_argv[i]); } } free(name); return result; } } } free(name); return strdup(""); } }</p>
<p>default: if (name[0] &gt;= '0' &amp;&amp; name[0] &lt;= '9') { // Handle positional parameters $0, $1, $2, etc. int pos = name[0] - '0';</p>
<p>if (pos == 0) { // $0 is the script/shell name free(name); return strdup((shell_argc &gt; 0 &amp;&amp; shell_argv[0]) ? shell_argv[0] : "lusush"); } else if (pos &gt; 0 &amp;&amp; pos &lt; shell_argc &amp;&amp; shell_argv[pos]) { // $1, $2, etc. are script arguments free(name); return strdup(shell_argv[pos]); } else { // Parameter doesn't exist, return empty string free(name); return strdup(""); } } break; } }</p>
<p>free(name); return value ? strdup(value) : strdup(""); } } }</p>
<p>return strdup(""); }</p>
<p>/**</p>
<p>Expand tilde to home directory</p>
<p>Handles ~ (current user) and ~user (specific user) expansion. Falls back to getpwuid if HOME is not set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>Text starting with ~ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Expanded path (caller must free) */ static char *expand_tilde(const char *text) { if (!text || text[0] != '~') { return strdup(text ? text : ""); }</dd></dl>
<p>// Find the end of the tilde expression (until '/' or end of string) const char *slash = strchr(text, '/'); const char *rest = slash ? slash : ""; size_t tilde_len = slash ? (size_t)(slash - text) : strlen(text);</p>
<p>if (tilde_len == 1) { // Simple ~ expansion to $HOME const char *home = getenv("HOME"); if (!home) { // Fallback if HOME is not set struct passwd *pw = getpwuid(getuid()); home = pw ? pw-&gt;pw_dir : "/"; }</p>
<p>if (strlen(rest) == 0) { return strdup(home); } else { size_t result_len = strlen(home) + strlen(rest) + 1; char *result = malloc(result_len); if (result) { strcpy(result, home); strcat(result, rest); } return result; } } else { // ~user expansion to user's home directory char *username = malloc(tilde_len); if (!username) { return strdup(text); }</p>
<p>strncpy(username, text + 1, tilde_len - 1); username[tilde_len - 1] = '\0';</p>
<p>struct passwd *pw = getpwnam(username); free(username);</p>
<p>if (!pw) { // User not found, return original text return strdup(text); }</p>
<p>if (strlen(rest) == 0) { return strdup(pw-&gt;pw_dir); } else { size_t result_len = strlen(pw-&gt;pw_dir) + strlen(rest) + 1; char *result = malloc(result_len); if (result) { strcpy(result, pw-&gt;pw_dir); strcat(result, rest); } return result; } } }</p>
<p>/**</p>
<p>Expand arithmetic expression $((...))</p>
<p>Evaluates arithmetic expressions and returns the result as a string. Sets expansion error flags on evaluation errors like division by zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context for variable lookup </td></tr>
    <tr><td class="paramname">arith_text</td><td>Arithmetic expression text </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result as string (caller must free), "0" on error */ static char *expand_arithmetic(<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *executor, const char *arith_text) { if (!executor || !arith_text) { return strdup("0"); }</dd></dl>
<p>// Use the modern arithmetic evaluator with executor context for scoped // variables char *result = arithm_expand_with_executor(executor, arith_text); if (result) { return result; }</p>
<p>// If arithm_expand returns NULL, there was an error (like division by zero) // Print error message and set exit status to indicate error if (arithm_error_flag &amp;&amp; arithm_error_message) { fprintf(stderr, "lusush: arithmetic: %s\n", arithm_error_message); } else { fprintf(stderr, "lusush: arithmetic: evaluation error\n"); }</p>
<p>// Set expansion error flag instead of immediate exit status executor-&gt;expansion_error = true; executor-&gt;expansion_exit_status = 1; return strdup(""); }</p>
<p>/**</p>
<p>Expand command substitution $(...) or <span class="tt">...</span></p>
<p>Forks a child process to execute the command and captures its stdout. Trailing newlines are stripped from the output. Uses the shell's own parser/executor to preserve function definitions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">cmd_text</td><td>Command text in $(...) or <span class="tt">...</span> format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Command output (caller must free) */ static char *expand_command_substitution(<a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *executor, const char *cmd_text) { if (!executor || !cmd_text) { return strdup(""); }</dd></dl>
<p>Extract command from  or <span class="tt">command</span> format char *command = NULL; if (strncmp(cmd_text, "$(", 2) == 0 &amp;&amp; cmd_text[strlen(cmd_text) - 1] == ')') { Extract from  size_t len = strlen(cmd_text) - 3; // Remove $( and ) command = malloc(len + 1); if (!command) { return strdup(""); } strncpy(command, cmd_text + 2, len); command[len] = '\0'; } else if (cmd_text[0] == '<span class="tt">' &amp;&amp; cmd_text[strlen(cmd_text) - 1] == '</span>') { Extract from <span class="tt">command</span> size_t len = strlen(cmd_text) - 2; // Remove backticks command = malloc(len + 1); if (!command) { return strdup(""); } strncpy(command, cmd_text + 1, len); command[len] = '\0'; } else { Already extracted command command = strdup(cmd_text); if (!command) { return strdup(""); } }</p>
<p>Expand variables in the command before executing it char *expanded_command = expand_variables_in_string(executor, command); free(command); if (!expanded_command) { return strdup(""); } command = expanded_command;</p>
<p>Create a pipe to capture command output int pipefd[2]; if (pipe(pipefd) == -1) { free(command); return strdup(""); }</p>
<p>pid_t pid = fork(); if (pid == -1) { close(pipefd[0]); close(pipefd[1]); free(command); return strdup(""); }</p>
<p>if (pid == 0) { Child process - execute command using lusush's own parser/executor close(pipefd[0]); // Close read end dup2(pipefd[1], STDOUT_FILENO); // Redirect stdout to pipe close(pipefd[1]);</p>
<p>Parse and execute command using lusush's own parser/executor This preserves all function definitions and variables in the child <a class="el" href="parser_8h.html#a219dbe70166fd30a1cd35d0ecdcdf5c8">parser_t</a> *parser = parser_new(command); int result = 127;</p>
<p>if (parser) { <a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *ast = parser_parse(parser); if (!parser_has_error(parser) &amp;&amp; ast) { Execute in current context (functions are inherited via fork) result = execute_node(executor, ast); free_node_tree(ast); } parser_free(parser); }</p>
<p>Ensure all output is flushed before exit fflush(stdout); _exit(result); } else { Parent process - read output close(pipefd[1]); // Close write end free(command);</p>
<p>char *output = malloc(1024); size_t output_size = 1024; size_t output_len = 0;</p>
<p>if (!output) { close(pipefd[0]); while (waitpid(pid, NULL, 0) == -1 &amp;&amp; errno == EINTR) ; return strdup(""); }</p>
<p>ssize_t bytes_read; char buffer[256];</p>
<p>Wait for child process to complete first, retrying on EINTR int status; while (waitpid(pid, &amp;status, 0) == -1 &amp;&amp; errno == EINTR) ;</p>
<p>Then read all available output while ((bytes_read = read(pipefd[0], buffer, sizeof(buffer))) &gt; 0) { if (output_len + bytes_read &gt;= output_size) { output_size *= 2; char *new_output = realloc(output, output_size); if (!new_output) { free(output); close(pipefd[0]); return strdup(""); } output = new_output; } memcpy(output + output_len, buffer, bytes_read); output_len += bytes_read; }</p>
<p>close(pipefd[0]);</p>
<p>Check for return value marker in output const char *return_marker = "__LUSUSH_RETURN__:"; const char *end_marker = ":__END__"; char *marker_pos = strstr(output, return_marker);</p>
<p>if (marker_pos) { Found return value marker, extract the return value char *value_start = marker_pos + strlen(return_marker); char *value_end = strstr(value_start, end_marker);</p>
<p>if (value_end) { Extract the return value size_t value_len = value_end - value_start; char *return_value = malloc(value_len + 1); if (return_value) { strncpy(return_value, value_start, value_len); return_value[value_len] = '\0';</p>
<p>Clean up the original output free(output); return return_value; } } }</p>
<p>Null terminate and remove trailing newlines output[output_len] = '\0'; while (output_len &gt; 0 &amp;&amp; (output[output_len - 1] == '<br  />
' || output[output_len - 1] == '\r')) { output[&ndash;output_len] = '\0'; }</p>
<p>return output; } }</p>
<p>/**</p>
<p>Copy function definitions between executors</p>
<p>Copies all function definitions from source to destination executor. Used when creating child executors that need access to parent functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Destination executor </td></tr>
    <tr><td class="paramname">src</td><td>Source executor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l05490">5490</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="a0a18d6faec574fe77a9727bb3ddd604e" name="a0a18d6faec574fe77a9727bb3ddd604e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a18d6faec574fe77a9727bb3ddd604e">&#9670;&#160;</a></span>copy_node_simple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> * copy_node_simple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>original</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple recursive node copy. </p>
<p>Creates a copy of an AST node and its children. Simpler than copy_ast_node, used for function definition copying.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>Node to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of node tree, or NULL on failure </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l05534">5534</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="aa0b9870b4ce2412b4a9e456741916790" name="aa0b9870b4ce2412b4a9e456741916790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b9870b4ce2412b4a9e456741916790">&#9670;&#160;</a></span>execute_assignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int execute_assignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>assignment</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9dbc89cb676bec1e5b8c141ed6b66f1d" name="a9dbc89cb676bec1e5b8c141ed6b66f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbc89cb676bec1e5b8c141ed6b66f1d">&#9670;&#160;</a></span>execute_brace_group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int execute_brace_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>group</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a59d52807b3517f3dad4f4b4036c7a8da" name="a59d52807b3517f3dad4f4b4036c7a8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d52807b3517f3dad4f4b4036c7a8da">&#9670;&#160;</a></span>execute_builtin_command()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int execute_builtin_command </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9dc16234881160b389b8849514bacb1f" name="a9dc16234881160b389b8849514bacb1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc16234881160b389b8849514bacb1f">&#9670;&#160;</a></span>execute_builtin_with_captured_stdout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int execute_builtin_with_captured_stdout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>command</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a31069b392c236239b782e95047fea273" name="a31069b392c236239b782e95047fea273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31069b392c236239b782e95047fea273">&#9670;&#160;</a></span>execute_case()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int execute_case </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>case_node</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa515bb6b938557b14609b8133e6c0754" name="aa515bb6b938557b14609b8133e6c0754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa515bb6b938557b14609b8133e6c0754">&#9670;&#160;</a></span>execute_command()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int execute_command </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>command</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a simple command node. </p>
<p>Handles command execution including:</p><ul>
<li>Variable assignments</li>
<li>Parameter expansions</li>
<li>Alias expansion</li>
<li>Builtin commands</li>
<li>Function calls</li>
<li>External commands with redirections</li>
<li>Auto-cd when enabled</li>
<li>Command auto-correction</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">command</td><td>Command node to execute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exit status of the command </dd></dl>
<p>Save old directory for event firing</p>
<p>Required by Spec 26 shell event hub to notify handlers of directory change with both old and new paths.</p>
<p>Fire directory changed event for LLE shell integration</p>
<p>This notifies the prompt composer which:</p><ul>
<li>Refreshes context.cwd</li>
<li>Invalidates all segment caches</li>
<li>Sets needs_regeneration flag</li>
<li>Triggers async git status refresh</li>
</ul>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l00694">694</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="aa11d6858edb1cbb30ffed009dc466935" name="aa11d6858edb1cbb30ffed009dc466935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11d6858edb1cbb30ffed009dc466935">&#9670;&#160;</a></span>execute_command_chain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int execute_command_chain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>first_command</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a chain of sibling commands. </p>
<p>Executes commands connected via next_sibling pointers. Handles loop control and exit-on-error semantics.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">first_command</td><td>First command in the sibling chain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exit status of last executed command </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l01273">1273</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="ab1a288ac82fefb05701aa9074735c56f" name="ab1a288ac82fefb05701aa9074735c56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a288ac82fefb05701aa9074735c56f">&#9670;&#160;</a></span>execute_command_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int execute_command_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>list</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a sequence of commands. </p>
<p>Executes commands in sequence, handling loop control (break/continue) and exit-on-error mode (set -e). Updates exit status after each command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">list</td><td>First node in the command list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exit status of last executed command </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l00626">626</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="aeb75df071b89f0beaa7a6234e09916dd" name="aeb75df071b89f0beaa7a6234e09916dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb75df071b89f0beaa7a6234e09916dd">&#9670;&#160;</a></span>execute_external_command()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int execute_external_command </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f49d270740eedc1d92703f6a58857f2" name="a9f49d270740eedc1d92703f6a58857f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f49d270740eedc1d92703f6a58857f2">&#9670;&#160;</a></span>execute_external_command_with_redirection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int execute_external_command_with_redirection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>redirect_stderr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae590f2fced7bd918ed39ee3629050828" name="ae590f2fced7bd918ed39ee3629050828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae590f2fced7bd918ed39ee3629050828">&#9670;&#160;</a></span>execute_external_command_with_setup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int execute_external_command_with_setup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>redirect_stderr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>command</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5b2439e18d1d45be354db76fb45de96" name="ad5b2439e18d1d45be354db76fb45de96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b2439e18d1d45be354db76fb45de96">&#9670;&#160;</a></span>execute_for()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int execute_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>for_node</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a for loop. </p>
<p>Iterates over a word list, setting the loop variable for each iteration. Handles "$@" specially to preserve word boundaries. Creates a loop scope for the iteration variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">for_node</td><td>For loop node with variable name in val.str </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exit status of last executed body command </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l01527">1527</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="a7ef8919127781d872d5d1be6330acda6" name="a7ef8919127781d872d5d1be6330acda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef8919127781d872d5d1be6330acda6">&#9670;&#160;</a></span>execute_function_call()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int execute_function_call </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>function_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a11762008e135435d99006aa3b751ebdc" name="a11762008e135435d99006aa3b751ebdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11762008e135435d99006aa3b751ebdc">&#9670;&#160;</a></span>execute_function_definition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int execute_function_definition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>function</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7337071947be7db6f50a9b0626ef887" name="ad7337071947be7db6f50a9b0626ef887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7337071947be7db6f50a9b0626ef887">&#9670;&#160;</a></span>execute_if()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int execute_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>if_node</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute an if statement. </p>
<p>Handles if/elif/else control flow. Children are organized as:</p><ul>
<li>First child: if condition</li>
<li>Second child: then body</li>
<li>Subsequent pairs: elif condition/body</li>
<li>Final unpaired child: else body (optional)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">if_node</td><td>If statement node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exit status of executed branch </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l01317">1317</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="a95e0b4e9a11d338abcafb7526ee92d14" name="a95e0b4e9a11d338abcafb7526ee92d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e0b4e9a11d338abcafb7526ee92d14">&#9670;&#160;</a></span>execute_logical_and()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int execute_logical_and </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>and_node</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute logical AND operator (&amp;&amp;). </p>
<p>Short-circuit evaluation: executes right operand only if left operand succeeds (returns 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">and_node</td><td>Logical AND node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exit status of last executed operand </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l01721">1721</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="a986ae10c01a19626f8b1196bebdaface" name="a986ae10c01a19626f8b1196bebdaface"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a986ae10c01a19626f8b1196bebdaface">&#9670;&#160;</a></span>execute_logical_or()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int execute_logical_or </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>or_node</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute logical OR operator (||). </p>
<p>Short-circuit evaluation: executes right operand only if left operand fails (returns non-zero).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">or_node</td><td>Logical OR node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exit status of last executed operand </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l01756">1756</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="aebcc5fabe9b7d531cf55a2fe708d77df" name="aebcc5fabe9b7d531cf55a2fe708d77df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebcc5fabe9b7d531cf55a2fe708d77df">&#9670;&#160;</a></span>execute_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int execute_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Core node execution dispatcher. </p>
<p>Dispatches execution to the appropriate handler based on node type. Handles debug tracing, breakpoints, and loop control. This is the central execution function that routes all AST node types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">node</td><td>AST node to execute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exit status of the executed node </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l00532">532</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="af8d85406503ff5c8afae9fdb1c9b71b5" name="af8d85406503ff5c8afae9fdb1c9b71b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d85406503ff5c8afae9fdb1c9b71b5">&#9670;&#160;</a></span>execute_pipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int execute_pipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>pipeline</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a pipeline of commands. </p>
<p>Implements a two-command pipeline with proper pipe setup. Supports pipefail mode where failure in any command causes pipeline failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">pipeline</td><td>Pipeline node containing commands </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exit status (last command's status, or first failure with pipefail) </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l01167">1167</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="a1a7378bea88f943f8dd65373a1b1767f" name="a1a7378bea88f943f8dd65373a1b1767f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7378bea88f943f8dd65373a1b1767f">&#9670;&#160;</a></span>execute_subshell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int execute_subshell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>subshell</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa465903e05bf8fdc05a7cd4e21dd8db" name="afa465903e05bf8fdc05a7cd4e21dd8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa465903e05bf8fdc05a7cd4e21dd8db">&#9670;&#160;</a></span>execute_until()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int execute_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>until_node</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute an until loop. </p>
<p>Executes body until condition returns success (0). Inverse of while loop - continues while condition fails. Supports break/continue with 10000 iteration safety limit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">until_node</td><td>Until loop node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exit status of last executed body command </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l01454">1454</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="a6fb7c4ad0b7e369a35e2e6717ca73f12" name="a6fb7c4ad0b7e369a35e2e6717ca73f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb7c4ad0b7e369a35e2e6717ca73f12">&#9670;&#160;</a></span>execute_while()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int execute_while </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>while_node</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a while loop. </p>
<p>Executes body while condition returns success (0). Supports break/continue and has a safety limit of 10000 iterations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">while_node</td><td>While loop node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exit status of last executed body command </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l01382">1382</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="a446f70a034fe775f6f070a247c2c23ad" name="a446f70a034fe775f6f070a247c2c23ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446f70a034fe775f6f070a247c2c23ad">&#9670;&#160;</a></span>executor_clear_script_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void executor_clear_script_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear script execution context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l00371">371</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="a64da5926bfc183927a4ea1b799668752" name="a64da5926bfc183927a4ea1b799668752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64da5926bfc183927a4ea1b799668752">&#9670;&#160;</a></span>executor_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * executor_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the last error message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error message string or NULL </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l00418">418</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="aec030f6ca5669a342a720e6f839621ce" name="aec030f6ca5669a342a720e6f839621ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec030f6ca5669a342a720e6f839621ce">&#9670;&#160;</a></span>executor_execute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int executor_execute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>ast</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute an AST node. </p>
<p>Main execution entry point. Handles both single commands and command sequences (commands with siblings).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">ast</td><td>Abstract syntax tree to execute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exit status of executed command </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l00445">445</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="abe2e9629c5153b82bd7dfa821937f1bc" name="abe2e9629c5153b82bd7dfa821937f1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2e9629c5153b82bd7dfa821937f1bc">&#9670;&#160;</a></span>executor_execute_command_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int executor_execute_command_line </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse and execute a command line string. </p>
<p>Parses the input string into an AST and executes it. Handles syntax check mode (set -n) where commands are parsed but not executed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">input</td><td>Shell command string to parse and execute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exit status of executed command, or error code </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l00477">477</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="a5fd8c68484dbb3118e1fa580d6b76b5f" name="a5fd8c68484dbb3118e1fa580d6b76b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd8c68484dbb3118e1fa580d6b76b5f">&#9670;&#160;</a></span>executor_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void executor_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an executor and all associated resources. </p>
<p>Frees the function table and script context. Does not free the symbol table as it may be externally managed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor to free </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l00283">283</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="a29c5fc83dbc17a32fde0f38320a8541f" name="a29c5fc83dbc17a32fde0f38320a8541f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c5fc83dbc17a32fde0f38320a8541f">&#9670;&#160;</a></span>executor_get_current_script_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * executor_get_current_script_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current script file path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Script file path or NULL </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l00388">388</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="ab0bfb08a579746c037a94a32f0ad1e8c" name="ab0bfb08a579746c037a94a32f0ad1e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0bfb08a579746c037a94a32f0ad1e8c">&#9670;&#160;</a></span>executor_get_current_script_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int executor_get_current_script_line </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current script line number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Line number or 0 if not in script </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l00398">398</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="a03faf0840b3389787512d7c75e91e132" name="a03faf0840b3389787512d7c75e91e132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03faf0840b3389787512d7c75e91e132">&#9670;&#160;</a></span>executor_has_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool executor_has_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if executor has an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an error occurred </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l00408">408</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="a739b7e1a070f9f04198ba27a43f106c8" name="a739b7e1a070f9f04198ba27a43f106c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739b7e1a070f9f04198ba27a43f106c8">&#9670;&#160;</a></span>executor_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> * executor_new </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new executor with global symbol table. </p>
<p>Allocates and initializes an executor context using the global symbol table manager. Initializes job control and sets default state.</p>
<dl class="section return"><dt>Returns</dt><dd>New executor instance or NULL on failure </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l00211">211</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="aef99707c58e0267bc37a9998f6675f91" name="aef99707c58e0267bc37a9998f6675f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef99707c58e0267bc37a9998f6675f91">&#9670;&#160;</a></span>executor_new_with_symtable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> * executor_new_with_symtable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="symtable_8h.html#affe05f5e84088a0115fe736424205a86">symtable_manager_t</a> *</td>          <td class="paramname"><span class="paramname"><em>symtable</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new executor with specified symbol table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symtable</td><td>Symbol table manager to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New executor instance or NULL on failure </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l00248">248</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="a6b1cdebbbebe8e5ec2af73d2c3a9f3a0" name="a6b1cdebbbebe8e5ec2af73d2c3a9f3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1cdebbbebe8e5ec2af73d2c3a9f3a0">&#9670;&#160;</a></span>executor_set_debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void executor_set_debug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>debug</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable debug mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">debug</td><td>True to enable debug output </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l00310">310</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="a4434d018255a2a080eacecce7033436f" name="a4434d018255a2a080eacecce7033436f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4434d018255a2a080eacecce7033436f">&#9670;&#160;</a></span>executor_set_interactive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void executor_set_interactive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>interactive</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set interactive mode flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">interactive</td><td>True for interactive shell mode </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l00325">325</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="a7e65660a63ec9184530f526a264ba75f" name="a7e65660a63ec9184530f526a264ba75f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e65660a63ec9184530f526a264ba75f">&#9670;&#160;</a></span>executor_set_script_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void executor_set_script_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>script_file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line_number</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set script execution context for debugging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">script_file</td><td>Script file path (NULL to clear) </td></tr>
    <tr><td class="paramname">line_number</td><td>Current line number in script </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l00351">351</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="af5a13b7516cbee2e0ff946ab74b5a70e" name="af5a13b7516cbee2e0ff946ab74b5a70e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a13b7516cbee2e0ff946ab74b5a70e">&#9670;&#160;</a></span>executor_set_symtable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void executor_set_symtable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="symtable_8h.html#affe05f5e84088a0115fe736424205a86">symtable_manager_t</a> *</td>          <td class="paramname"><span class="paramname"><em>symtable</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the symbol table manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">symtable</td><td>Symbol table manager to use </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l00337">337</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="a2374b6e1dbfbe98e1c79e59dd5360a50" name="a2374b6e1dbfbe98e1c79e59dd5360a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2374b6e1dbfbe98e1c79e59dd5360a50">&#9670;&#160;</a></span>expand_arithmetic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * expand_arithmetic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>arith_text</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a532b3d93ddecde5f7a3abc71c2c8996f" name="a532b3d93ddecde5f7a3abc71c2c8996f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532b3d93ddecde5f7a3abc71c2c8996f">&#9670;&#160;</a></span>expand_brace_pattern()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char ** expand_brace_pattern </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>expanded_count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08153adbce7290e076b7162f47fa7d39" name="a08153adbce7290e076b7162f47fa7d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08153adbce7290e076b7162f47fa7d39">&#9670;&#160;</a></span>expand_command_substitution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * expand_command_substitution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>cmd_text</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1fdd06789897d80bc145c64329d4528b" name="a1fdd06789897d80bc145c64329d4528b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fdd06789897d80bc145c64329d4528b">&#9670;&#160;</a></span>expand_glob_pattern()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char ** expand_glob_pattern </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>expanded_count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac33dd755c5ac9849667a7c621af907d7" name="ac33dd755c5ac9849667a7c621af907d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33dd755c5ac9849667a7c621af907d7">&#9670;&#160;</a></span>expand_if_needed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * expand_if_needed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>text</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98a44ad874c697e1bf44d92f5481b5a2" name="a98a44ad874c697e1bf44d92f5481b5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a44ad874c697e1bf44d92f5481b5a2">&#9670;&#160;</a></span>expand_quoted_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * expand_quoted_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa926ce63c9d5b9ab94018579bc8735a" name="afa926ce63c9d5b9ab94018579bc8735a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa926ce63c9d5b9ab94018579bc8735a">&#9670;&#160;</a></span>expand_tilde()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * expand_tilde </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a581de7e6ab02ee64c6f6c89ca72b5f09" name="a581de7e6ab02ee64c6f6c89ca72b5f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581de7e6ab02ee64c6f6c89ca72b5f09">&#9670;&#160;</a></span>expand_variable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * expand_variable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>var_text</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac677e58947a4edf22eec7208cc22a3da" name="ac677e58947a4edf22eec7208cc22a3da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac677e58947a4edf22eec7208cc22a3da">&#9670;&#160;</a></span>find_function()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="executor_8h.html#a4ff86c222eadffcfcce6f45bbe194029">function_def_t</a> * find_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>function_name</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a01a1ef635b10c0c1f73ae027e25bb905" name="a01a1ef635b10c0c1f73ae027e25bb905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a1ef635b10c0c1f73ae027e25bb905">&#9670;&#160;</a></span>has_stdout_redirections()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool has_stdout_redirections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>command</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e6ad81b6186b16d2d461ae2ea187c5c" name="a0e6ad81b6186b16d2d461ae2ea187c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6ad81b6186b16d2d461ae2ea187c5c">&#9670;&#160;</a></span>ifs_field_split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char ** ifs_field_split </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>text</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>ifs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split text into fields using IFS delimiters. </p>
<p>Performs POSIX IFS field splitting on text. Default IFS is space, tab, and newline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>Text to split </td></tr>
    <tr><td class="paramname">ifs</td><td>Field separator characters (NULL for default) </td></tr>
    <tr><td class="paramname">count</td><td>Output: number of fields produced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of field strings (caller must free), or NULL on error </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l01818">1818</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="a4f2288fe86c9ffe5f48768a6fe941b5b" name="a4f2288fe86c9ffe5f48768a6fe941b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2288fe86c9ffe5f48768a6fe941b5b">&#9670;&#160;</a></span>initialize_job_control()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_job_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b6e605d61c1af767a519410f61f85dc" name="a3b6e605d61c1af767a519410f61f85dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6e605d61c1af767a519410f61f85dc">&#9670;&#160;</a></span>is_assignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_assignment </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ace283bf4be85f4b662474c8f96d10bc6" name="ace283bf4be85f4b662474c8f96d10bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace283bf4be85f4b662474c8f96d10bc6">&#9670;&#160;</a></span>is_builtin_command()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_builtin_command </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>cmd</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afdc21ec4aead52dbc2e25cc6d3de5cc8" name="afdc21ec4aead52dbc2e25cc6d3de5cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc21ec4aead52dbc2e25cc6d3de5cc8">&#9670;&#160;</a></span>is_function_defined()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_function_defined </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>function_name</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac80add05e51d4943255d11d44937b324" name="ac80add05e51d4943255d11d44937b324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80add05e51d4943255d11d44937b324">&#9670;&#160;</a></span>is_pipefail_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_pipefail_enabled </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="posix__opts_8c_source.html#l00117">117</a> of file <a class="el" href="posix__opts_8c_source.html">posix_opts.c</a>.</p>

</div>
</div>
<a id="a1595c3f36f971bc24bbff109fc3fd551" name="a1595c3f36f971bc24bbff109fc3fd551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1595c3f36f971bc24bbff109fc3fd551">&#9670;&#160;</a></span>is_posix_mode_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_posix_mode_enabled </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="posix__opts_8c_source.html#l00115">115</a> of file <a class="el" href="posix__opts_8c_source.html">posix_opts.c</a>.</p>

</div>
</div>
<a id="a1d3d31c65b2394077e5dd363bbdbae0d" name="a1d3d31c65b2394077e5dd363bbdbae0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3d31c65b2394077e5dd363bbdbae0d">&#9670;&#160;</a></span>is_privileged_command_allowed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_privileged_command_allowed </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>command</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if command is allowed in privileged mode. </p>
<p>In privileged mode, certain commands are restricted for security:</p><ul>
<li>Commands with absolute/relative paths (containing '/')</li>
<li>Dangerous builtins: exec, cd, set</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>Command name to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if command is allowed, false if blocked </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l00130">130</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="a3afc6a154b62137a3cc1f109459919d9" name="a3afc6a154b62137a3cc1f109459919d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3afc6a154b62137a3cc1f109459919d9">&#9670;&#160;</a></span>is_privileged_path_modification_allowed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_privileged_path_modification_allowed </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>var_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if environment variable modification is allowed in privileged mode. </p>
<p>In privileged mode, security-sensitive variables cannot be modified:</p><ul>
<li>PATH: Command search path</li>
<li>IFS: Input field separator</li>
<li>ENV: Startup script path</li>
<li>SHELL: Shell path</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var_name</td><td>Variable name to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if modification is allowed, false if blocked </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l00189">189</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="a182eb179c5c84fd514c227613822bbac" name="a182eb179c5c84fd514c227613822bbac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182eb179c5c84fd514c227613822bbac">&#9670;&#160;</a></span>is_privileged_redirection_allowed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_privileged_redirection_allowed </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if redirection target is allowed in privileged mode. </p>
<p>In privileged mode, certain redirections are restricted:</p><ul>
<li>Absolute paths (starting with '/')</li>
<li>Parent directory references ('../')</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Redirection target path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if redirection is allowed, false if blocked </dd></dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l00159">159</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="aa47981dbc29d238de71be5ce9263e5de" name="aa47981dbc29d238de71be5ce9263e5de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47981dbc29d238de71be5ce9263e5de">&#9670;&#160;</a></span>is_stdout_captured()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_stdout_captured </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a00f062e9edf50854864902595dbb91f0" name="a00f062e9edf50854864902595dbb91f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f062e9edf50854864902595dbb91f0">&#9670;&#160;</a></span>match_pattern()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool match_pattern </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f5cf712959b1ffcb8d98982da06e608" name="a7f5cf712959b1ffcb8d98982da06e608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5cf712959b1ffcb8d98982da06e608">&#9670;&#160;</a></span>needs_brace_expansion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool needs_brace_expansion </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f3bcfecb2b7169220221548fcdff65e" name="a0f3bcfecb2b7169220221548fcdff65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3bcfecb2b7169220221548fcdff65e">&#9670;&#160;</a></span>needs_glob_expansion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool needs_glob_expansion </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaae5b6b7c661d080e6352a8f63fb1b04" name="aaae5b6b7c661d080e6352a8f63fb1b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae5b6b7c661d080e6352a8f63fb1b04">&#9670;&#160;</a></span>set_executor_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_executor_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>message</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an error on the executor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Executor context </td></tr>
    <tr><td class="paramname">message</td><td>Error message </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l00428">428</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
<a id="a50d296cbbc773a18f0ec69d88383f655" name="a50d296cbbc773a18f0ec69d88383f655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d296cbbc773a18f0ec69d88383f655">&#9670;&#160;</a></span>store_function()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int store_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a> *</td>          <td class="paramname"><span class="paramname"><em>executor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>function_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_8h.html#a7c02633e18d6aa5f58539b75f08753d9">node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>body</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="executor_8h.html#ac0f6db05e3be0c03ea208716041861d1">function_param_t</a> *</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>param_count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3291a198aef87aa21f88b93ed6e6c02f" name="a3291a198aef87aa21f88b93ed6e6c02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3291a198aef87aa21f88b93ed6e6c02f">&#9670;&#160;</a></span>validate_function_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int validate_function_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="executor_8h.html#a4ff86c222eadffcfcce6f45bbe194029">function_def_t</a> *</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="aa6126a46019a074d653f294cc2af4208" name="aa6126a46019a074d653f294cc2af4208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6126a46019a074d653f294cc2af4208">&#9670;&#160;</a></span>current_executor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arithmetic_8h.html#a206ad8422f6de6d90dad90563d8ae6db">executor_t</a>* current_executor = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Global executor instance </p>

<p class="definition">Definition at line <a class="el" href="executor_8c_source.html#l00045">45</a> of file <a class="el" href="executor_8c_source.html">executor.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a href="executor_8c.html">executor.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
