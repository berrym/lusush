name: CI

on:
  push:
    branches: [master, feature/lle]
  pull_request:
    branches: [master]

jobs:
  build-and-test:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest]

    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies (Ubuntu)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y meson ninja-build lcov valgrind

      - name: Install dependencies (macOS)
        if: runner.os == 'macOS'
        run: |
          brew install meson ninja lcov

      - name: Clean build directory
        run: rm -rf build

      - name: Configure (with coverage)
        run: |
          meson setup build -Db_coverage=true

      - name: Build
        run: |
          meson compile -C build

      - name: Run tests
        run: |
          meson test -C build --print-errorlogs

      - name: Generate coverage report
        if: matrix.os == 'ubuntu-latest'
        run: |
          cd build
          lcov --capture --directory . --output-file coverage.info --ignore-errors mismatch,gcov
          lcov --remove coverage.info '/usr/*' --output-file coverage.info --ignore-errors unused
          lcov --remove coverage.info '*/tests/*' --output-file coverage.info --ignore-errors unused
          lcov --list coverage.info

      - name: Upload coverage to Codecov
        if: matrix.os == 'ubuntu-latest'
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: build/coverage.info
          flags: unittests
          name: codecov-lush
          fail_ci_if_error: false
          verbose: true

  # Memory leak detection on Linux using Valgrind
  memory-check-linux:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y meson ninja-build valgrind

      - name: Configure (release build for accurate leak detection)
        run: |
          meson setup build --buildtype=debugoptimized

      - name: Build
        run: |
          meson compile -C build

      - name: Run comprehensive memory check
        id: valgrind
        run: |
          # Create a comprehensive test script
          cat > /tmp/memcheck_tests.sh << 'EOF'
          # Basic execution
          echo "Testing basic execution"
          x=hello
          echo $x

          # Arrays
          arr=(one two three)
          echo ${arr[0]} ${arr[@]}
          echo ${#arr[@]}

          # Arithmetic
          (( y = 5 + 3 ))
          echo $y

          # Control structures
          for i in 1 2 3; do echo $i; done
          if true; then echo yes; fi
          case foo in foo) echo matched;; esac

          # Functions
          myfunc() { echo "in function: $1"; }
          myfunc test

          # Command substitution
          z=$(echo captured)
          echo $z

          # Pipes and redirections
          echo pipe | cat
          echo redirect > /tmp/lush_test_redirect.txt
          cat /tmp/lush_test_redirect.txt
          rm -f /tmp/lush_test_redirect.txt

          # Parameter expansion
          str="hello world"
          echo ${str^^}
          echo ${str//world/there}

          # Builtins
          type echo
          cd /tmp && pwd && cd -

          # Extended test
          [[ "foo" == "foo" ]] && echo "match"

          # Exit cleanly
          exit 0
          EOF

          # Run valgrind with comprehensive checks
          valgrind \
            --leak-check=full \
            --show-leak-kinds=definite,indirect \
            --errors-for-leak-kinds=definite \
            --error-exitcode=1 \
            --track-origins=yes \
            --log-file=valgrind-report.txt \
            ./build/lush /tmp/memcheck_tests.sh

          VALGRIND_EXIT=$?

          echo "=== Valgrind Report ==="
          cat valgrind-report.txt

          # Extract summary for annotation
          if grep -q "definitely lost: 0 bytes" valgrind-report.txt; then
            echo "memory_status=clean" >> $GITHUB_OUTPUT
          else
            echo "memory_status=leaks" >> $GITHUB_OUTPUT
          fi

          exit $VALGRIND_EXIT

      - name: Upload Valgrind report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: valgrind-report-linux
          path: valgrind-report.txt

  # Memory leak detection on macOS using leaks tool
  memory-check-macos:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          brew install meson ninja

      - name: Configure (release build)
        run: |
          meson setup build --buildtype=debugoptimized

      - name: Build
        run: |
          meson compile -C build

      - name: Run comprehensive memory check
        id: leaks
        timeout-minutes: 5
        run: |
          # Create a simpler test script that avoids features that may cause
          # the leaks tool to hang (pipes, command substitution with subshells)
          cat > /tmp/memcheck_tests.sh << 'EOF'
          echo "Testing basic execution"
          x=hello
          echo $x
          arr=(one two three)
          echo ${arr[0]} ${arr[@]}
          (( y = 5 + 3 ))
          echo $y
          for i in 1 2 3; do echo $i; done
          if true; then echo yes; fi
          myfunc() { echo "in function: $1"; }
          myfunc test
          str="hello world"
          echo ${str^^}
          [[ "foo" == "foo" ]] && echo "match"
          exit 0
          EOF

          # Run with leaks tool using timeout to prevent hanging
          # MallocStackLogging enables memory tracking
          export MallocStackLogging=1

          # Use timeout command to prevent infinite hang
          if timeout 120 leaks --atExit -- ./build/lush /tmp/memcheck_tests.sh > leaks-report.txt 2>&1; then
            LEAKS_EXIT=0
          else
            LEAKS_EXIT=$?
          fi

          echo "=== Leaks Report ==="
          cat leaks-report.txt || echo "(no report generated)"

          # Check for leaks (0 leaks = success)
          if grep -q "0 leaks for 0 total leaked bytes" leaks-report.txt 2>/dev/null; then
            echo "memory_status=clean" >> $GITHUB_OUTPUT
            exit 0
          elif grep -q "leaks Report Version:" leaks-report.txt 2>/dev/null; then
            # leaks tool ran but found issues
            LEAK_COUNT=$(grep -o '[0-9]* leaks for' leaks-report.txt | grep -o '[0-9]*' | head -1)
            if [ "$LEAK_COUNT" = "0" ] || [ -z "$LEAK_COUNT" ]; then
              echo "memory_status=clean" >> $GITHUB_OUTPUT
              exit 0
            else
              echo "memory_status=leaks" >> $GITHUB_OUTPUT
              echo "::warning::macOS leaks detected: $LEAK_COUNT leaks found"
              # Warning only for now - macOS leaks can have false positives
              exit 0
            fi
          else
            echo "memory_status=unknown" >> $GITHUB_OUTPUT
            echo "::warning::Could not parse leaks output (exit code: $LEAKS_EXIT)"
            # Don't fail the build for macOS leaks issues - it's informational
            exit 0
          fi

      - name: Upload leaks report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: leaks-report-macos
          path: leaks-report.txt
