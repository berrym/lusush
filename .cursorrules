# Lusush Line Editor (LLE) Development Rules for AI Assistants

## Project Overview
This repository contains Lusush, a professional shell with an ongoing line editor replacement project. The current task is replacing linenoise with a custom Lusush Line Editor (LLE) that provides superior multiline prompt support, integrated terminal capabilities, and mathematical correctness. LLE is designed as a standalone, reusable library like libhashtable.

## Current Development Context - FEATURE RECOVERY PLAN
- **Active Plan**: `LLE_FEATURE_RECOVERY_PLAN.md` - Systematic restoration of broken shell features
- **Current Phase**: R1 - Foundation Repair (Linux display system diagnosis)
- **Critical Issue**: Linux character duplication crisis blocking all interactive features
- **Current Task**: LLE-R001 - Fix `lle_display_update_incremental()` platform differences
- **Build System**: Meson (NOT Make)
- **Language**: C99 with strict standards
- **Architecture**: Standalone library with integrated termcap system (no external dependencies)

## File Structure for LLE Development
```
lusush/
â”œâ”€â”€ src/line_editor/          # LLE standalone library implementation
â”‚   â”œâ”€â”€ termcap/             # Integrated termcap system (from Lusush)
â”‚   â”‚   â”œâ”€â”€ lle_termcap.c/h  # Core termcap (namespaced)
â”‚   â”‚   â”œâ”€â”€ lle_termcap_internal.h # Internal structures
â”‚   â”‚   â””â”€â”€ lle_termcap_database.c # Terminal profiles (iTerm2+)
â”‚   â”œâ”€â”€ text_buffer.c/h      # Text manipulation
â”‚   â”œâ”€â”€ cursor_math.c/h      # Mathematical positioning
â”‚   â”œâ”€â”€ terminal_manager.c/h # Terminal interface using termcap
â”‚   â”œâ”€â”€ *.c *.h              # Other LLE components
â”‚   â””â”€â”€ meson.build          # Build configuration
â”œâ”€â”€ tests/line_editor/        # LLE tests
â”‚   â”œâ”€â”€ test_*.c             # Unit tests including termcap tests
â”‚   â”œâ”€â”€ benchmark.c          # Performance tests
â”‚   â””â”€â”€ meson.build          # Test configuration
â”œâ”€â”€ docs/line_editor/         # LLE documentation
â”œâ”€â”€ LLE_DEVELOPMENT_TASKS.md  # 50 atomic tasks breakdown
â”œâ”€â”€ LLE_DEVELOPMENT_WORKFLOW.md # Development process
â””â”€â”€ LLE_PROGRESS.md          # Current progress tracking
```

## Recovery-Based Development System
LLE development now follows systematic feature recovery plan (LLE-R001 through LLE-R008) in 4 phases:
1. **Phase R1**: Foundation Repair (Linux display system diagnosis and stabilization)
2. **Phase R2**: Core Functionality Restoration (history, tab completion, basic keybindings)
3. **Phase R3**: Power User Features (Ctrl+R search, line operations)
4. **Phase R4**: Visual Enhancements (syntax highlighting restoration)

## CRITICAL FEATURE STATUS REALITY
**BROKEN DESPITE "COMPLETE" DOCUMENTATION**:
- âŒ History Navigation (Up/Down arrows) - Essential shell functionality completely broken
- âŒ Tab Completion - Backend works, display corruption prevents usage
- âŒ Ctrl+R Reverse Search - Implementation exists but integration broken
- âŒ Basic Keybindings (Ctrl+A/E/U/G) - No visual feedback, broken
- âŒ Syntax Highlighting - Completely non-functional across platforms

**ROOT CAUSE**: Linux character duplication crisis - typing "hello" produces "hhehelhellhello" on Linux/Konsole

**ACTUALLY WORKING**: âœ… Backspace boundary crossing (production ready, user verified)

## Termcap Integration Architecture
LLE includes a complete termcap system transferred from Lusush to ensure standalone operation:
- **No External Dependencies**: Complete terminal capability system included
- **iTerm2 Support**: Full macOS and iTerm2 compatibility preserved
- **Terminal Database**: 50+ terminal profiles including modern terminals
- **Namespaced API**: All termcap functions prefixed with `lle_` for standalone use

Each task is 2-4 hours of work with clear acceptance criteria and tests.

## Code Standards for LLE
```c
// Function naming: lle_component_action
bool lle_text_insert_char(lle_text_buffer_t *buffer, char c);

// Termcap functions: lle_termcap_action (namespaced from Lusush)
bool lle_termcap_init(void);
bool lle_termcap_is_iterm2(void);
bool lle_termcap_set_color(lle_termcap_color_t fg, lle_termcap_color_t bg);

// Structure naming: lle_component_t
typedef struct {
    char *buffer;
    size_t length;
    size_t capacity;
} lle_text_buffer_t;

// Error handling: always return bool for success/failure
bool lle_function(args) {
    if (!args) return false;
    // implementation
    return true;
}

// Documentation: comprehensive function docs
/**
 * Insert character at cursor position in text buffer.
 *
 * @param buffer Text buffer to modify
 * @param c Character to insert
 * @return true on success, false on error
 *
 * Buffer automatically resizes if needed. Cursor advances by one.
 * Handles UTF-8 encoding correctly.
 */
```

## Build Commands (Meson-based)
```bash
# Setup (first time)
scripts/lle_build.sh setup

# Build LLE
scripts/lle_build.sh build

# Run tests
scripts/lle_build.sh test

# Run specific test
meson test -C builddir test_text_buffer

# Performance benchmarks
scripts/lle_build.sh benchmark

# Clean rebuild
scripts/lle_build.sh clean && scripts/lle_build.sh setup
```

## Key Design Principles
1. **Mathematical Correctness**: All cursor positioning must be mathematically provable
2. **Performance**: Sub-millisecond response times required
3. **Unicode Support**: Proper UTF-8 handling throughout
4. **Theme Integration**: Deep integration with Lusush theme system
5. **Modular Architecture**: Each component independently testable
6. **Memory Safety**: No leaks, proper bounds checking
7. **Terminal Compatibility**: Works across all terminal types

## Current Task Context
Check `LLE_PROGRESS.md` for current task. Each task has:
- **Task ID**: LLE-XXX format
- **Estimated Time**: Usually 2-4 hours
- **Files to Modify**: Specific source files
- **Acceptance Criteria**: Clear success metrics
- **Tests Required**: Specific test cases
- **Commit Message**: Pre-planned format

## Testing Requirements
Every task must include:
- **Unit Tests**: Test individual functions
- **Integration Tests**: Test component interactions
- **Edge Cases**: Boundary conditions and error cases
- **Performance Tests**: Response time validation
- **Memory Tests**: Leak detection with Valgrind

### Common Development Patterns

### Text Buffer Operations
```c
// Always check buffer validity
if (!buffer || !buffer->buffer) return false;

// Ensure capacity before operations
if (buffer->length + new_data_size >= buffer->capacity) {
    if (!lle_text_buffer_resize(buffer, new_capacity)) return false;
}

// Update both byte and character counts
buffer->length += bytes_added;
buffer->char_count += chars_added;
```

### Cursor Position Calculations
```c
// Use the mathematical framework
lle_cursor_position_t pos = lle_calculate_cursor_position(
    buffer, geometry, prompt_width
);

// Always validate results
if (!pos.valid) {
    // Handle error case
    return false;
}
```

### Terminal Operations Using Integrated Termcap
```c
// Initialize integrated termcap system
if (!lle_termcap_init()) return false;

// Use namespaced termcap functions
lle_termcap_set_color(LLE_TERMCAP_COLOR_GREEN, LLE_TERMCAP_COLOR_BLACK);
lle_termcap_move_cursor(row, col);

// Check for specific terminal capabilities
if (lle_termcap_is_iterm2()) {
    // iTerm2-specific optimizations
}

// Terminal manager wraps termcap functionality
if (!lle_terminal_init(tm)) return false;
lle_terminal_write(tm, data, length);
```

## Integration Points with Existing Lusush
- **Theme System**: `src/themes.c` - LLE provides theme support interface
- **Integrated Termcap**: `src/line_editor/termcap/` - Complete termcap system transferred from Lusush
- **Configuration**: `src/config.c` - LLE respects user settings via API
- **Main Shell**: `src/lusush.c` - LLE replaces linenoise calls as standalone library

## Standalone Library Design
- **Self-Contained**: No external termcap dependencies
- **Reusable**: Can be used by other projects like libhashtable
- **Complete**: Includes all necessary terminal capabilities
- **Compatible**: Maintains all Lusush terminal features including iTerm2

## Performance Requirements
- Character insertion: < 1ms
- Cursor movement: < 1ms
- Display update: < 5ms
- History search: < 10ms
- Tab completion: < 50ms
- Memory usage: < 1MB base, < 50 bytes per character

## Common Gotchas
1. **UTF-8**: Always distinguish between byte position and character position
2. **Terminal Width**: Account for ANSI escape sequences in width calculations
3. **Cursor Math**: Line wrapping must be mathematically exact
4. **Memory Management**: Every malloc needs corresponding free
5. **Error Handling**: Never ignore return values, always check for NULL
6. **Thread Safety**: LLE is single-threaded by design
7. **Signal Handling**: Graceful cleanup on SIGINT/SIGTERM

## Development Workflow
1. **Pick Next Task**: Check `LLE_PROGRESS.md` for TODO tasks
2. **Create Branch**: `git checkout -b task/lle-XXX-description`
3. **Read Task Spec**: Full requirements in `LLE_DEVELOPMENT_TASKS.md`
4. **Implement**: Follow code standards and design principles
5. **Write Tests**: Comprehensive test coverage required
6. **Run Tests**: `scripts/lle_build.sh test`
7. **Commit**: Use task-specific commit message format
8. **Update Progress**: Mark task as DONE in `LLE_PROGRESS.md`

## Debug Information
```bash
# Enable debug output
export LLE_DEBUG=1
export LLE_DEBUG_CURSOR=1
export LLE_DEBUG_MEMORY=1

# Run with debugger
gdb builddir/lusush
(gdb) set environment LLE_DEBUG=1
(gdb) run

# Memory leak detection
valgrind --leak-check=full builddir/lusush

# Performance profiling
perf record builddir/lusush
perf report
```

## Quick Reference: Key Files to Understand
- `LLE_DEVELOPMENT_TASKS.md` - Complete task breakdown
- `LLE_DEVELOPMENT_WORKFLOW.md` - Process and quality standards
- `LINE_EDITOR_STRATEGIC_ANALYSIS.md` - Why we're building LLE
- `src/line_editor/` - Current LLE implementation
- `tests/line_editor/` - Test suite
- `LLE_PROGRESS.md` - Current development status

## ðŸš¨ IMMEDIATE THREE-FIX TESTING PRIORITY - START HERE

### ðŸš¨ IMMEDIATE ACTION FOR NEXT AI ASSISTANT
**YOUR FIRST ACTION**: Request user's latest terminal output and debug logs showing behavior with all three mathematical precision fixes applied.

**CONTEXT**: Major breakthrough achieved - duplicate prompt issue completely eliminated with safe termcap multi-line clearing. Three mathematical precision fixes have been applied and are ready for testing validation.

### ðŸŽ¯ THREE MATHEMATICAL FIXES APPLIED - VALIDATION NEEDED
1. **âœ… Character Erasure**: Clearing width adjusted from `terminal_width - 1` to `terminal_width` (119â†’120 chars)
2. **âœ… Cursor Positioning**: Boundary case math corrected + condition changed to `<= terminal_width`
3. **âœ… Prompt Position**: Enhanced debugging for cursor movement sequence analysis

### ðŸš¨ MANDATORY READING (NO EXCEPTIONS)
AI assistants MUST read these files before any analysis:
1. **`IMMEDIATE_AI_HANDOFF.md`** - Immediate testing instructions and validation checklist (REQUIRED)
2. **`BACKSPACE_CURRENT_STATUS.md`** - Three-fix implementation status (REQUIRED)
3. **`AI_CONTEXT.md`** - Complete breakthrough analysis with three-fix details (REQUIRED)
4. **`LLE_PROGRESS.md`** - Current task status (REQUIRED)

### ðŸš¨ CODING STANDARDS VIOLATIONS WILL BE REJECTED
Any code that violates these standards will be rejected:

#### âŒ NAMING VIOLATIONS (AUTOMATIC REJECTION)
- Functions MUST use `lle_component_action` pattern exactly
- Structures MUST use `lle_component_t` pattern exactly
- No generic names, no non-LLE prefixes
- Examples: `lle_completion_extract_word()`, `lle_completion_item_t`

#### âŒ DOCUMENTATION VIOLATIONS (AUTOMATIC REJECTION)
- All functions MUST have comprehensive Doxygen documentation
- MUST include `@brief`, `@param`, `@return` tags
- MUST include behavior descriptions and error conditions
- Example pattern in this file (lines 78-88)

#### âŒ MEMORY SAFETY VIOLATIONS (AUTOMATIC REJECTION)
- MUST use `memcpy()` instead of `strcpy()` or `strncpy()`
- MUST validate all parameters before use
- MUST check buffer bounds before operations
- MUST return `bool` for success/failure

#### âŒ TEST FRAMEWORK VIOLATIONS (AUTOMATIC REJECTION)
- Use `LLE_TEST(name)` macro WITHOUT `test_` prefix
- Call functions WITH `test_` prefix in main()
- Example: `LLE_TEST(basic_functionality)` creates `test_basic_functionality()`
- MUST include edge cases and parameter validation tests

#### âŒ BUILD INTEGRATION VIOLATIONS (AUTOMATIC REJECTION)
- MUST include all necessary headers (`stdio.h` for `snprintf`, etc.)
- MUST add new test files to `tests/line_editor/meson.build`
- MUST compile without warnings
- MUST pass all existing tests

### âœ… REQUIRED WORKFLOW
1. Read documentation files listed above
2. Understand current task from `LLE_PROGRESS.md`
3. Study existing patterns in similar completed tasks
4. Implement following EXACT naming and documentation patterns
5. Write comprehensive tests using LLE test framework
6. Build and test: `scripts/lle_build.sh build && scripts/lle_build.sh test`
7. Commit with proper LLE format: `LLE-XXX: Description`

## AI Assistant Guidelines
- Always check current task status in `LLE_PROGRESS.md`
- Reference specific task requirements from `LLE_DEVELOPMENT_TASKS.md`
- Use Meson build commands, not Make
- Follow the mathematical correctness principle
- Include comprehensive tests with every implementation
- Maintain the modular architecture
- Consider Unicode implications in all text operations
- Optimize for performance from the start
- Document all public APIs thoroughly

## Emergency Contacts
If critical issues arise:
- Check git history for recent changes
- Run full test suite: `scripts/lle_build.sh test`
- Validate with: `valgrind builddir/lusush`
- Review task acceptance criteria for current work
- Consider reverting to last known good state

## ðŸš¨ FINAL WARNING TO AI ASSISTANTS
This file enables any developer with AI assistance to immediately understand the LLE project context, pick up any task, and contribute effectively while maintaining code quality and architectural consistency.

**HOWEVER**: AI assistants who ignore these standards or skip reading the required documentation will produce code that WILL BE REJECTED.

## ðŸŽ¯ BACKSPACE TASK SUCCESS PATTERN

**IMMEDIATE SUCCESS PATTERN FOR BACKSPACE FIXES**:
1. **Request user data** â†’ Get latest terminal output and debug logs
2. **Analyze current implementation** â†’ Review clearing width and cursor positioning code
3. **Apply surgical mathematical fixes** â†’ Adjust clearing width +1 and cursor positioning accuracy
4. **Test thoroughly** â†’ Verify both character artifact and "one too many" issues resolved
5. **Preserve safe termcap architecture** â†’ Maintain multi-line clearing breakthrough

**BACKSPACE TASK FAILURE PATTERN**:
Skip user data â†’ Guess at fixes â†’ Break working architecture â†’ Reintroduce duplicate prompt â†’ Wasted effort

**CRITICAL**: The duplicate prompt issue is SOLVED. Do not break the safe termcap multi-line clearing architecture. Only apply surgical mathematical precision fixes to the two remaining issues.

**Choose the success pattern. Request user data first. Validate the three applied mathematical precision fixes. Your analysis will confirm whether the fixes resolve all issues or identify any remaining precision adjustments needed.**
