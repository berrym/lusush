# Lusush Line Editor (LLE) Development Rules for AI Assistants

## Project Overview
This repository contains Lusush, a professional shell with an ongoing line editor replacement project. The current task is replacing linenoise with a custom Lusush Line Editor (LLE) that provides superior multiline prompt support, integrated terminal capabilities, and mathematical correctness. LLE is designed as a standalone, reusable library like libhashtable.

## 🚨 CRITICAL: EMERGENCY SITUATION - DISPLAY SYSTEM COMPLETELY BROKEN
- **MANDATORY READING**: `HISTORY_NAVIGATION_CRISIS_ANALYSIS.md` - Complete failure analysis and recovery paths
- **EMERGENCY STATUS**: ALL history navigation broken - display refresh system failure
- **HUMAN VERIFIED CRISIS**: Buffer updates correctly but display doesn't refresh until user types
- **IMMEDIATE REQUIREMENT**: Revert to working state and fix display system regression
- **Build System**: Meson (NOT Make)
- **Language**: C99 with strict standards
- **Architecture**: Standalone library with integrated termcap system (no external dependencies)

## File Structure for LLE Development
```
lusush/
├── src/line_editor/          # LLE standalone library implementation
│   ├── termcap/             # Integrated termcap system (from Lusush)
│   │   ├── lle_termcap.c/h  # Core termcap (namespaced)
│   │   ├── lle_termcap_internal.h # Internal structures
│   │   └── lle_termcap_database.c # Terminal profiles (iTerm2+)
│   ├── text_buffer.c/h      # Text manipulation
│   ├── cursor_math.c/h      # Mathematical positioning
│   ├── terminal_manager.c/h # Terminal interface using termcap
│   ├── *.c *.h              # Other LLE components
│   └── meson.build          # Build configuration
├── tests/line_editor/        # LLE tests
│   ├── test_*.c             # Unit tests including termcap tests
│   ├── benchmark.c          # Performance tests
│   └── meson.build          # Test configuration
├── docs/line_editor/         # LLE documentation
├── LLE_DEVELOPMENT_TASKS.md  # 50 atomic tasks breakdown
├── LLE_DEVELOPMENT_WORKFLOW.md # Development process
└── LLE_PROGRESS.md          # Current progress tracking
```

## 🚨 INTERACTIVE REALITY-BASED DEVELOPMENT (MANDATORY)
AI assistants MUST follow actual interactive behavior, not documentation claims:

### ✅ **VERIFIED WORKING (Human Tested)**
- **Single-line history navigation** - Works perfectly
- **Backspace boundary crossing** - 100% complete, all platforms
- **Character input and basic editing** - Works reliably
- **Space-and-backspace clearing** - Works for single-line content

### ❌ **VERIFIED BROKEN (Human Tested)**
- **Multiline history clearing** - CRITICAL: Content doesn't clear, draws at wrong location
- **Display system for content replacement** - Causes prompt redrawing cascades
- **ANSI escape sequences** - Unreliable, claim success but don't actually clear

### 🚨 **DEVELOPMENT PRIORITY (ONLY FOCUS)**
**SINGLE OBJECTIVE**: Fix multiline history content clearing
- Success criteria: Human test user verification ONLY
- Visual terminal behavior is the only measure of success
- NO other features until this is verified working

## Termcap Integration Architecture
LLE includes a complete termcap system transferred from Lusush to ensure standalone operation:
- **No External Dependencies**: Complete terminal capability system included
- **iTerm2 Support**: Full macOS and iTerm2 compatibility preserved
- **Terminal Database**: 50+ terminal profiles including modern terminals
- **Namespaced API**: All termcap functions prefixed with `lle_` for standalone use

Each task is 2-4 hours of work with clear acceptance criteria and tests.

## Code Standards for LLE
```c
// Function naming: lle_component_action
bool lle_text_insert_char(lle_text_buffer_t *buffer, char c);

// Termcap functions: lle_termcap_action (namespaced from Lusush)
bool lle_termcap_init(void);
bool lle_termcap_is_iterm2(void);
bool lle_termcap_set_color(lle_termcap_color_t fg, lle_termcap_color_t bg);

// Structure naming: lle_component_t
typedef struct {
    char *buffer;
    size_t length;
    size_t capacity;
} lle_text_buffer_t;

// Error handling: always return bool for success/failure
bool lle_function(args) {
    if (!args) return false;
    // implementation
    return true;
}

// Documentation: comprehensive function docs
/**
 * Insert character at cursor position in text buffer.
 *
 * @param buffer Text buffer to modify
 * @param c Character to insert
 * @return true on success, false on error
 *
 * Buffer automatically resizes if needed. Cursor advances by one.
 * Handles UTF-8 encoding correctly.
 */
```

## Build Commands (Meson-based)
```bash
# Setup (first time)
scripts/lle_build.sh setup

# Build LLE
scripts/lle_build.sh build

# Run tests
scripts/lle_build.sh test

# Run specific test
meson test -C builddir test_text_buffer

# Performance benchmarks
scripts/lle_build.sh benchmark

# Clean rebuild
scripts/lle_build.sh clean && scripts/lle_build.sh setup
```

## Key Design Principles
1. **Mathematical Correctness**: All cursor positioning must be mathematically provable
2. **Performance**: Sub-millisecond response times required
3. **Unicode Support**: Proper UTF-8 handling throughout
4. **Theme Integration**: Deep integration with Lusush theme system
5. **Modular Architecture**: Each component independently testable
6. **Memory Safety**: No leaks, proper bounds checking
7. **Terminal Compatibility**: Works across all terminal types

## Current Task Context
Check `LLE_PROGRESS.md` for current task. Each task has:
- **Task ID**: LLE-XXX format
- **Estimated Time**: Usually 2-4 hours
- **Files to Modify**: Specific source files
- **Acceptance Criteria**: Clear success metrics
- **Tests Required**: Specific test cases
- **Commit Message**: Pre-planned format

## Testing Requirements
Every task must include:
- **Unit Tests**: Test individual functions
- **Integration Tests**: Test component interactions
- **Edge Cases**: Boundary conditions and error cases
- **Performance Tests**: Response time validation
- **Memory Tests**: Leak detection with Valgrind

### Common Development Patterns

### Text Buffer Operations
```c
// Always check buffer validity
if (!buffer || !buffer->buffer) return false;

// Ensure capacity before operations
if (buffer->length + new_data_size >= buffer->capacity) {
    if (!lle_text_buffer_resize(buffer, new_capacity)) return false;
}

// Update both byte and character counts
buffer->length += bytes_added;
buffer->char_count += chars_added;
```

### Cursor Position Calculations
```c
// Use the mathematical framework
lle_cursor_position_t pos = lle_calculate_cursor_position(
    buffer, geometry, prompt_width
);

// Always validate results
if (!pos.valid) {
    // Handle error case
    return false;
}
```

### Terminal Operations Using Integrated Termcap
```c
// Initialize integrated termcap system
if (!lle_termcap_init()) return false;

// Use namespaced termcap functions
lle_termcap_set_color(LLE_TERMCAP_COLOR_GREEN, LLE_TERMCAP_COLOR_BLACK);
lle_termcap_move_cursor(row, col);

// Check for specific terminal capabilities
if (lle_termcap_is_iterm2()) {
    // iTerm2-specific optimizations
}

// Terminal manager wraps termcap functionality
if (!lle_terminal_init(tm)) return false;
lle_terminal_write(tm, data, length);
```

## Integration Points with Existing Lusush
- **Theme System**: `src/themes.c` - LLE provides theme support interface
- **Integrated Termcap**: `src/line_editor/termcap/` - Complete termcap system transferred from Lusush
- **Configuration**: `src/config.c` - LLE respects user settings via API
- **Main Shell**: `src/lusush.c` - LLE replaces linenoise calls as standalone library

## Standalone Library Design
- **Self-Contained**: No external termcap dependencies
- **Reusable**: Can be used by other projects like libhashtable
- **Complete**: Includes all necessary terminal capabilities
- **Compatible**: Maintains all Lusush terminal features including iTerm2

## Performance Requirements
- Character insertion: < 1ms
- Cursor movement: < 1ms
- Display update: < 5ms
- History search: < 10ms
- Tab completion: < 50ms
- Memory usage: < 1MB base, < 50 bytes per character

## Common Gotchas
1. **UTF-8**: Always distinguish between byte position and character position
2. **Terminal Width**: Account for ANSI escape sequences in width calculations
3. **Cursor Math**: Line wrapping must be mathematically exact
4. **Memory Management**: Every malloc needs corresponding free
5. **Error Handling**: Never ignore return values, always check for NULL
6. **Thread Safety**: LLE is single-threaded by design
7. **Signal Handling**: Graceful cleanup on SIGINT/SIGTERM

## Development Workflow
1. **Pick Next Task**: Check `LLE_PROGRESS.md` for TODO tasks
2. **Create Branch**: `git checkout -b task/lle-XXX-description`
3. **Read Task Spec**: Full requirements in `LLE_DEVELOPMENT_TASKS.md`
4. **Implement**: Follow code standards and design principles
5. **Write Tests**: Comprehensive test coverage required
6. **Run Tests**: `scripts/lle_build.sh test`
7. **Commit**: Use task-specific commit message format
8. **Update Progress**: Mark task as DONE in `LLE_PROGRESS.md`

## Debug Information
```bash
# Enable debug output
export LLE_DEBUG=1
export LLE_DEBUG_CURSOR=1
export LLE_DEBUG_MEMORY=1

# Run with debugger
gdb builddir/lusush
(gdb) set environment LLE_DEBUG=1
(gdb) run

# Memory leak detection
valgrind --leak-check=full builddir/lusush

# Performance profiling
perf record builddir/lusush
perf report
```

## Quick Reference: Key Files to Understand
- `LLE_DEVELOPMENT_TASKS.md` - Complete task breakdown
- `LLE_DEVELOPMENT_WORKFLOW.md` - Process and quality standards
- `LINE_EDITOR_STRATEGIC_ANALYSIS.md` - Why we're building LLE
- `src/line_editor/` - Current LLE implementation
- `tests/line_editor/` - Test suite
- `LLE_PROGRESS.md` - Current development status

## 🚨 **EMERGENCY RECOVERY REQUIRED - START HERE

### 🚨 IMMEDIATE ACTION FOR NEXT AI ASSISTANT
**YOUR FIRST ACTION**: Execute emergency revert to last working state before display system regression.

**CONTEXT**: Critical system failure - display refresh mechanism broken. All history navigation non-functional. Buffer updates correctly but display doesn't refresh until user types. Multiple clearing attempts caused fundamental regression.

### 🚨 EMERGENCY RECOVERY PROTOCOL
1. **🚨 REVERT IMMEDIATELY**: `git checkout <last_working_commit> src/line_editor/`
2. **🚨 VERIFY RECOVERY**: Test that history navigation shows content immediately
3. **🚨 IDENTIFY REGRESSION**: Analyze what broke display refresh mechanism

### 🚨 MANDATORY READING (NO EXCEPTIONS)
AI assistants MUST read these files before any analysis:
1. **`IMMEDIATE_AI_HANDOFF.md`** - Immediate testing instructions and validation checklist (REQUIRED)
2. **`BACKSPACE_CURRENT_STATUS.md`** - Three-fix implementation status (REQUIRED)
3. **`AI_CONTEXT.md`** - Complete breakthrough analysis with three-fix details (REQUIRED)
4. **`LLE_PROGRESS.md`** - Current task status (REQUIRED)

### 🚨 CODING STANDARDS VIOLATIONS WILL BE REJECTED
Any code that violates these standards will be rejected:

#### ❌ NAMING VIOLATIONS (AUTOMATIC REJECTION)
- Functions MUST use `lle_component_action` pattern exactly
- Structures MUST use `lle_component_t` pattern exactly
- No generic names, no non-LLE prefixes
- Examples: `lle_completion_extract_word()`, `lle_completion_item_t`

#### ❌ DOCUMENTATION VIOLATIONS (AUTOMATIC REJECTION)
- All functions MUST have comprehensive Doxygen documentation
- MUST include `@brief`, `@param`, `@return` tags
- MUST include behavior descriptions and error conditions
- Example pattern in this file (lines 78-88)

#### ❌ MEMORY SAFETY VIOLATIONS (AUTOMATIC REJECTION)
- MUST use `memcpy()` instead of `strcpy()` or `strncpy()`
- MUST validate all parameters before use
- MUST check buffer bounds before operations
- MUST return `bool` for success/failure

#### ❌ TEST FRAMEWORK VIOLATIONS (AUTOMATIC REJECTION)
- Use `LLE_TEST(name)` macro WITHOUT `test_` prefix
- Call functions WITH `test_` prefix in main()
- Example: `LLE_TEST(basic_functionality)` creates `test_basic_functionality()`
- MUST include edge cases and parameter validation tests

#### ❌ BUILD INTEGRATION VIOLATIONS (AUTOMATIC REJECTION)
- MUST include all necessary headers (`stdio.h` for `snprintf`, etc.)
- MUST add new test files to `tests/line_editor/meson.build`
- MUST compile without warnings
- MUST pass all existing tests

### ✅ REQUIRED WORKFLOW
1. Read documentation files listed above
2. Understand current task from `LLE_PROGRESS.md`
3. Study existing patterns in similar completed tasks
4. Implement following EXACT naming and documentation patterns
5. Write comprehensive tests using LLE test framework
6. Build and test: `scripts/lle_build.sh build && scripts/lle_build.sh test`
7. Commit with proper LLE format: `LLE-XXX: Description`

## 🚨 AI Assistant Guidelines - INTERACTIVE REALITY FIRST

### **MANDATORY FIRST ACTIONS**
1. **Read `LLE_INTERACTIVE_REALITY.md`** - Understand what actually works vs claims
2. **Focus exclusively on multiline history clearing** - NO other work
3. **Request human testing verification** for every change attempt
4. **Use only proven patterns** - space-and-backspace works for single-line

### **DEVELOPMENT CONSTRAINTS**
- Visual terminal behavior is the only measure of success
- Mathematical correctness means nothing if visual result is wrong
- Debug logs show calculations but not visual reality
- Human testing is mandatory - no exceptions

### **TECHNICAL REQUIREMENTS**
- Use Meson build commands, not Make
- Follow space-and-backspace clearing pattern (proven working)
- Avoid display system rendering (causes prompt cascading)
- Avoid ANSI escape sequences (unreliable)
- Maintain exact character counting (works correctly)

## 🚨 Emergency Protocols - Multiline Clearing Focus

### **If Multiline Clearing Attempts Fail**
1. **Stop immediately** - no further attempts without human guidance
2. **Request debug logs** from human testing: `LLE_DEBUG=1 ./builddir/lusush 2>/tmp/debug.log`
3. **Analyze visual behavior** - not just mathematical calculations
4. **Revert to working state** if breaking single-line functionality
5. **Document findings** in interactive reality terms

### **Build and Test Commands**
- Build: `scripts/lle_build.sh build`
- Test interactively: `LLE_DEBUG=1 ./builddir/lusush`
- Debug logs: `LLE_DEBUG=1 LLE_CURSOR_DEBUG=1 ./builddir/lusush 2>/tmp/debug.log`
- Human testing verification required for every change

## 🚨 FINAL WARNING TO AI ASSISTANTS - INTERACTIVE REALITY COMPLIANCE

### **MANDATORY REQUIREMENTS**
Any AI assistant working on LLE MUST:
1. **Read and follow `LLE_INTERACTIVE_REALITY.md`** - No exceptions
2. **Focus exclusively on multiline history clearing** - NO other features
3. **Request human testing verification** for every change
4. **Use only proven working patterns** - space-and-backspace for single-line
5. **Acknowledge visual terminal behavior as only success measure**

### **AUTOMATIC REJECTION CRITERIA**
Code will be REJECTED if:
- Attempts any clearing work before display system is fixed
- Doesn't immediately revert to working state
- Ignores display refresh system regression
- Works on features other than fixing core display functionality
- Skips verification that history navigation works immediately
- Doesn't understand this is a display problem, not a clearing problem

### **EMERGENCY RECOVERY PATTERN**
The only acceptable approach:
1. Execute immediate revert to last working state
2. Verify basic history navigation works (shows content immediately)
3. Identify what broke display refresh during clearing attempts
4. Fix display system regression before any clearing work
5. NO clearing work until display refresh mechanism works perfectly

## 🎯 BACKSPACE TASK SUCCESS PATTERN

**IMMEDIATE SUCCESS PATTERN FOR BACKSPACE FIXES**:
1. **Request user data** → Get latest terminal output and debug logs
2. **Analyze current implementation** → Review clearing width and cursor positioning code
3. **Apply surgical mathematical fixes** → Adjust clearing width +1 and cursor positioning accuracy
4. **Test thoroughly** → Verify both character artifact and "one too many" issues resolved
5. **Preserve safe termcap architecture** → Maintain multi-line clearing breakthrough

**DISPLAY CRISIS FAILURE PATTERN**:
Skip revert → Attempt more clearing → Break display system further → Ignore fundamental regression → Total system failure

**CRITICAL**: The display refresh system is BROKEN. History navigation completely non-functional. Buffer updates correctly but display doesn't refresh until user types. This is NOT a clearing problem - it's a display system regression.

**Choose the emergency recovery pattern. Revert immediately. Verify history navigation works instantly. Fix display system before any clearing attempts. This is a fundamental system failure requiring immediate intervention.**
