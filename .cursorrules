# Lusush Line Editor (LLE) Development Rules for AI Assistants

## Project Overview
This repository contains Lusush, a professional shell with an ongoing line editor replacement project. The current task is replacing linenoise with a custom Lusush Line Editor (LLE) that provides superior multiline prompt support, integrated terminal capabilities, and mathematical correctness. LLE is designed as a standalone, reusable library like libhashtable.

## 🚨 CRITICAL: CURRENT DEVELOPMENT CONTEXT - MULTILINE HISTORY CLEARING CRISIS
- **MANDATORY READING**: `LLE_INTERACTIVE_REALITY.md` - What actually works vs documentation claims
- **SINGLE FOCUS**: Multiline history navigation clearing (BROKEN)
- **HUMAN VERIFIED STATUS**: Single-line works perfectly, multiline completely broken
- **NO OTHER WORK**: Until multiline clearing verified working by human testing
- **Build System**: Meson (NOT Make)
- **Language**: C99 with strict standards
- **Architecture**: Standalone library with integrated termcap system (no external dependencies)

## File Structure for LLE Development
```
lusush/
├── src/line_editor/          # LLE standalone library implementation
│   ├── termcap/             # Integrated termcap system (from Lusush)
│   │   ├── lle_termcap.c/h  # Core termcap (namespaced)
│   │   ├── lle_termcap_internal.h # Internal structures
│   │   └── lle_termcap_database.c # Terminal profiles (iTerm2+)
│   ├── text_buffer.c/h      # Text manipulation
│   ├── cursor_math.c/h      # Mathematical positioning
│   ├── terminal_manager.c/h # Terminal interface using termcap
│   ├── *.c *.h              # Other LLE components
│   └── meson.build          # Build configuration
├── tests/line_editor/        # LLE tests
│   ├── test_*.c             # Unit tests including termcap tests
│   ├── benchmark.c          # Performance tests
│   └── meson.build          # Test configuration
├── docs/line_editor/         # LLE documentation
├── LLE_DEVELOPMENT_TASKS.md  # 50 atomic tasks breakdown
├── LLE_DEVELOPMENT_WORKFLOW.md # Development process
└── LLE_PROGRESS.md          # Current progress tracking
```

## 🚨 INTERACTIVE REALITY-BASED DEVELOPMENT (MANDATORY)
AI assistants MUST follow actual interactive behavior, not documentation claims:

### ✅ **VERIFIED WORKING (Human Tested)**
- **Single-line history navigation** - Works perfectly
- **Backspace boundary crossing** - 100% complete, all platforms
- **Character input and basic editing** - Works reliably
- **Space-and-backspace clearing** - Works for single-line content

### ❌ **VERIFIED BROKEN (Human Tested)**
- **Multiline history clearing** - CRITICAL: Content doesn't clear, draws at wrong location
- **Display system for content replacement** - Causes prompt redrawing cascades
- **ANSI escape sequences** - Unreliable, claim success but don't actually clear

### 🚨 **DEVELOPMENT PRIORITY (ONLY FOCUS)**
**SINGLE OBJECTIVE**: Fix multiline history content clearing
- Success criteria: Human test user verification ONLY
- Visual terminal behavior is the only measure of success
- NO other features until this is verified working

## Termcap Integration Architecture
LLE includes a complete termcap system transferred from Lusush to ensure standalone operation:
- **No External Dependencies**: Complete terminal capability system included
- **iTerm2 Support**: Full macOS and iTerm2 compatibility preserved
- **Terminal Database**: 50+ terminal profiles including modern terminals
- **Namespaced API**: All termcap functions prefixed with `lle_` for standalone use

Each task is 2-4 hours of work with clear acceptance criteria and tests.

## Code Standards for LLE
```c
// Function naming: lle_component_action
bool lle_text_insert_char(lle_text_buffer_t *buffer, char c);

// Termcap functions: lle_termcap_action (namespaced from Lusush)
bool lle_termcap_init(void);
bool lle_termcap_is_iterm2(void);
bool lle_termcap_set_color(lle_termcap_color_t fg, lle_termcap_color_t bg);

// Structure naming: lle_component_t
typedef struct {
    char *buffer;
    size_t length;
    size_t capacity;
} lle_text_buffer_t;

// Error handling: always return bool for success/failure
bool lle_function(args) {
    if (!args) return false;
    // implementation
    return true;
}

// Documentation: comprehensive function docs
/**
 * Insert character at cursor position in text buffer.
 *
 * @param buffer Text buffer to modify
 * @param c Character to insert
 * @return true on success, false on error
 *
 * Buffer automatically resizes if needed. Cursor advances by one.
 * Handles UTF-8 encoding correctly.
 */
```

## Build Commands (Meson-based)
```bash
# Setup (first time)
scripts/lle_build.sh setup

# Build LLE
scripts/lle_build.sh build

# Run tests
scripts/lle_build.sh test

# Run specific test
meson test -C builddir test_text_buffer

# Performance benchmarks
scripts/lle_build.sh benchmark

# Clean rebuild
scripts/lle_build.sh clean && scripts/lle_build.sh setup
```

## Key Design Principles
1. **Mathematical Correctness**: All cursor positioning must be mathematically provable
2. **Performance**: Sub-millisecond response times required
3. **Unicode Support**: Proper UTF-8 handling throughout
4. **Theme Integration**: Deep integration with Lusush theme system
5. **Modular Architecture**: Each component independently testable
6. **Memory Safety**: No leaks, proper bounds checking
7. **Terminal Compatibility**: Works across all terminal types

## Current Task Context
Check `LLE_PROGRESS.md` for current task. Each task has:
- **Task ID**: LLE-XXX format
- **Estimated Time**: Usually 2-4 hours
- **Files to Modify**: Specific source files
- **Acceptance Criteria**: Clear success metrics
- **Tests Required**: Specific test cases
- **Commit Message**: Pre-planned format

## Testing Requirements
Every task must include:
- **Unit Tests**: Test individual functions
- **Integration Tests**: Test component interactions
- **Edge Cases**: Boundary conditions and error cases
- **Performance Tests**: Response time validation
- **Memory Tests**: Leak detection with Valgrind

### Common Development Patterns

### Text Buffer Operations
```c
// Always check buffer validity
if (!buffer || !buffer->buffer) return false;

// Ensure capacity before operations
if (buffer->length + new_data_size >= buffer->capacity) {
    if (!lle_text_buffer_resize(buffer, new_capacity)) return false;
}

// Update both byte and character counts
buffer->length += bytes_added;
buffer->char_count += chars_added;
```

### Cursor Position Calculations
```c
// Use the mathematical framework
lle_cursor_position_t pos = lle_calculate_cursor_position(
    buffer, geometry, prompt_width
);

// Always validate results
if (!pos.valid) {
    // Handle error case
    return false;
}
```

### Terminal Operations Using Integrated Termcap
```c
// Initialize integrated termcap system
if (!lle_termcap_init()) return false;

// Use namespaced termcap functions
lle_termcap_set_color(LLE_TERMCAP_COLOR_GREEN, LLE_TERMCAP_COLOR_BLACK);
lle_termcap_move_cursor(row, col);

// Check for specific terminal capabilities
if (lle_termcap_is_iterm2()) {
    // iTerm2-specific optimizations
}

// Terminal manager wraps termcap functionality
if (!lle_terminal_init(tm)) return false;
lle_terminal_write(tm, data, length);
```

## Integration Points with Existing Lusush
- **Theme System**: `src/themes.c` - LLE provides theme support interface
- **Integrated Termcap**: `src/line_editor/termcap/` - Complete termcap system transferred from Lusush
- **Configuration**: `src/config.c` - LLE respects user settings via API
- **Main Shell**: `src/lusush.c` - LLE replaces linenoise calls as standalone library

## Standalone Library Design
- **Self-Contained**: No external termcap dependencies
- **Reusable**: Can be used by other projects like libhashtable
- **Complete**: Includes all necessary terminal capabilities
- **Compatible**: Maintains all Lusush terminal features including iTerm2

## Performance Requirements
- Character insertion: < 1ms
- Cursor movement: < 1ms
- Display update: < 5ms
- History search: < 10ms
- Tab completion: < 50ms
- Memory usage: < 1MB base, < 50 bytes per character

## Common Gotchas
1. **UTF-8**: Always distinguish between byte position and character position
2. **Terminal Width**: Account for ANSI escape sequences in width calculations
3. **Cursor Math**: Line wrapping must be mathematically exact
4. **Memory Management**: Every malloc needs corresponding free
5. **Error Handling**: Never ignore return values, always check for NULL
6. **Thread Safety**: LLE is single-threaded by design
7. **Signal Handling**: Graceful cleanup on SIGINT/SIGTERM

## Development Workflow
1. **Pick Next Task**: Check `LLE_PROGRESS.md` for TODO tasks
2. **Create Branch**: `git checkout -b task/lle-XXX-description`
3. **Read Task Spec**: Full requirements in `LLE_DEVELOPMENT_TASKS.md`
4. **Implement**: Follow code standards and design principles
5. **Write Tests**: Comprehensive test coverage required
6. **Run Tests**: `scripts/lle_build.sh test`
7. **Commit**: Use task-specific commit message format
8. **Update Progress**: Mark task as DONE in `LLE_PROGRESS.md`

## Debug Information
```bash
# Enable debug output
export LLE_DEBUG=1
export LLE_DEBUG_CURSOR=1
export LLE_DEBUG_MEMORY=1

# Run with debugger
gdb builddir/lusush
(gdb) set environment LLE_DEBUG=1
(gdb) run

# Memory leak detection
valgrind --leak-check=full builddir/lusush

# Performance profiling
perf record builddir/lusush
perf report
```

## Quick Reference: Key Files to Understand
- `LLE_DEVELOPMENT_TASKS.md` - Complete task breakdown
- `LLE_DEVELOPMENT_WORKFLOW.md` - Process and quality standards
- `LINE_EDITOR_STRATEGIC_ANALYSIS.md` - Why we're building LLE
- `src/line_editor/` - Current LLE implementation
- `tests/line_editor/` - Test suite
- `LLE_PROGRESS.md` - Current development status

## 🚨 IMMEDIATE THREE-FIX TESTING PRIORITY - START HERE

### 🚨 IMMEDIATE ACTION FOR NEXT AI ASSISTANT
**YOUR FIRST ACTION**: Request user's latest terminal output and debug logs showing behavior with all three mathematical precision fixes applied.

**CONTEXT**: Major breakthrough achieved - duplicate prompt issue completely eliminated with safe termcap multi-line clearing. Three mathematical precision fixes have been applied and are ready for testing validation.

### 🎯 THREE MATHEMATICAL FIXES APPLIED - VALIDATION NEEDED
1. **✅ Character Erasure**: Clearing width adjusted from `terminal_width - 1` to `terminal_width` (119→120 chars)
2. **✅ Cursor Positioning**: Boundary case math corrected + condition changed to `<= terminal_width`
3. **✅ Prompt Position**: Enhanced debugging for cursor movement sequence analysis

### 🚨 MANDATORY READING (NO EXCEPTIONS)
AI assistants MUST read these files before any analysis:
1. **`IMMEDIATE_AI_HANDOFF.md`** - Immediate testing instructions and validation checklist (REQUIRED)
2. **`BACKSPACE_CURRENT_STATUS.md`** - Three-fix implementation status (REQUIRED)
3. **`AI_CONTEXT.md`** - Complete breakthrough analysis with three-fix details (REQUIRED)
4. **`LLE_PROGRESS.md`** - Current task status (REQUIRED)

### 🚨 CODING STANDARDS VIOLATIONS WILL BE REJECTED
Any code that violates these standards will be rejected:

#### ❌ NAMING VIOLATIONS (AUTOMATIC REJECTION)
- Functions MUST use `lle_component_action` pattern exactly
- Structures MUST use `lle_component_t` pattern exactly
- No generic names, no non-LLE prefixes
- Examples: `lle_completion_extract_word()`, `lle_completion_item_t`

#### ❌ DOCUMENTATION VIOLATIONS (AUTOMATIC REJECTION)
- All functions MUST have comprehensive Doxygen documentation
- MUST include `@brief`, `@param`, `@return` tags
- MUST include behavior descriptions and error conditions
- Example pattern in this file (lines 78-88)

#### ❌ MEMORY SAFETY VIOLATIONS (AUTOMATIC REJECTION)
- MUST use `memcpy()` instead of `strcpy()` or `strncpy()`
- MUST validate all parameters before use
- MUST check buffer bounds before operations
- MUST return `bool` for success/failure

#### ❌ TEST FRAMEWORK VIOLATIONS (AUTOMATIC REJECTION)
- Use `LLE_TEST(name)` macro WITHOUT `test_` prefix
- Call functions WITH `test_` prefix in main()
- Example: `LLE_TEST(basic_functionality)` creates `test_basic_functionality()`
- MUST include edge cases and parameter validation tests

#### ❌ BUILD INTEGRATION VIOLATIONS (AUTOMATIC REJECTION)
- MUST include all necessary headers (`stdio.h` for `snprintf`, etc.)
- MUST add new test files to `tests/line_editor/meson.build`
- MUST compile without warnings
- MUST pass all existing tests

### ✅ REQUIRED WORKFLOW
1. Read documentation files listed above
2. Understand current task from `LLE_PROGRESS.md`
3. Study existing patterns in similar completed tasks
4. Implement following EXACT naming and documentation patterns
5. Write comprehensive tests using LLE test framework
6. Build and test: `scripts/lle_build.sh build && scripts/lle_build.sh test`
7. Commit with proper LLE format: `LLE-XXX: Description`

## 🚨 AI Assistant Guidelines - INTERACTIVE REALITY FIRST

### **MANDATORY FIRST ACTIONS**
1. **Read `LLE_INTERACTIVE_REALITY.md`** - Understand what actually works vs claims
2. **Focus exclusively on multiline history clearing** - NO other work
3. **Request human testing verification** for every change attempt
4. **Use only proven patterns** - space-and-backspace works for single-line

### **DEVELOPMENT CONSTRAINTS**
- Visual terminal behavior is the only measure of success
- Mathematical correctness means nothing if visual result is wrong
- Debug logs show calculations but not visual reality
- Human testing is mandatory - no exceptions

### **TECHNICAL REQUIREMENTS**
- Use Meson build commands, not Make
- Follow space-and-backspace clearing pattern (proven working)
- Avoid display system rendering (causes prompt cascading)
- Avoid ANSI escape sequences (unreliable)
- Maintain exact character counting (works correctly)

## 🚨 Emergency Protocols - Multiline Clearing Focus

### **If Multiline Clearing Attempts Fail**
1. **Stop immediately** - no further attempts without human guidance
2. **Request debug logs** from human testing: `LLE_DEBUG=1 ./builddir/lusush 2>/tmp/debug.log`
3. **Analyze visual behavior** - not just mathematical calculations
4. **Revert to working state** if breaking single-line functionality
5. **Document findings** in interactive reality terms

### **Build and Test Commands**
- Build: `scripts/lle_build.sh build`
- Test interactively: `LLE_DEBUG=1 ./builddir/lusush`
- Debug logs: `LLE_DEBUG=1 LLE_CURSOR_DEBUG=1 ./builddir/lusush 2>/tmp/debug.log`
- Human testing verification required for every change

## 🚨 FINAL WARNING TO AI ASSISTANTS - INTERACTIVE REALITY COMPLIANCE

### **MANDATORY REQUIREMENTS**
Any AI assistant working on LLE MUST:
1. **Read and follow `LLE_INTERACTIVE_REALITY.md`** - No exceptions
2. **Focus exclusively on multiline history clearing** - NO other features
3. **Request human testing verification** for every change
4. **Use only proven working patterns** - space-and-backspace for single-line
5. **Acknowledge visual terminal behavior as only success measure**

### **AUTOMATIC REJECTION CRITERIA**
Code will be REJECTED if:
- Works on features other than multiline clearing
- Uses `lle_display_render()` for content replacement
- Uses ANSI escape sequences for clearing
- Relies on mathematical calculations without visual verification
- Skips human testing verification
- Ignores interactive reality constraints

### **SUCCESS PATTERN**
The only acceptable approach:
1. Understand current multiline clearing failure mode
2. Extend proven single-line clearing pattern to multiline
3. Test with human verification at each step
4. Focus on visual terminal behavior, not debug logs
5. NO other work until human verifies multiline clearing perfection

## 🎯 BACKSPACE TASK SUCCESS PATTERN

**IMMEDIATE SUCCESS PATTERN FOR BACKSPACE FIXES**:
1. **Request user data** → Get latest terminal output and debug logs
2. **Analyze current implementation** → Review clearing width and cursor positioning code
3. **Apply surgical mathematical fixes** → Adjust clearing width +1 and cursor positioning accuracy
4. **Test thoroughly** → Verify both character artifact and "one too many" issues resolved
5. **Preserve safe termcap architecture** → Maintain multi-line clearing breakthrough

**BACKSPACE TASK FAILURE PATTERN**:
Skip user data → Guess at fixes → Break working architecture → Reintroduce duplicate prompt → Wasted effort

**CRITICAL**: The duplicate prompt issue is SOLVED. Do not break the safe termcap multi-line clearing architecture. Only apply surgical mathematical precision fixes to the two remaining issues.

**Choose the success pattern. Request user data first. Validate the three applied mathematical precision fixes. Your analysis will confirm whether the fixes resolve all issues or identify any remaining precision adjustments needed.**
