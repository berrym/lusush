# Lusush Line Editor (LLE) Development Rules for AI Assistants

## Project Overview
This repository contains Lusush, a professional shell with an ongoing line editor replacement project. The current task is implementing a unified display state synchronization system to eliminate display corruption and state divergence issues. LLE is designed as a standalone, reusable library like libhashtable.

## 🎯 BREAKTHROUGH: UNIFIED DISPLAY STATE SYNCHRONIZATION SOLUTION IMPLEMENTED
- **MANDATORY READING**: `UNIFIED_DISPLAY_STATE_SOLUTION.md` - Complete architectural solution
- **CRITICAL PROBLEM SOLVED**: "display state never matched terminal state especially after ANSI clear sequences"
- **SOLUTION STATUS**: Bidirectional terminal-display state tracking system implemented
- **CURRENT MISSION**: Integrate state synchronization into existing codebase
- **Build System**: Meson (NOT Make)
- **Language**: C99 with strict standards
- **Architecture**: Standalone library with unified state tracking system

## File Structure for LLE Development
```
lusush/
├── src/line_editor/          # LLE standalone library implementation
│   ├── termcap/             # Integrated termcap system (from Lusush)
│   │   ├── lle_termcap.c/h  # Core termcap (namespaced)
│   │   ├── lle_termcap_internal.h # Internal structures
│   │   └── lle_termcap_database.c # Terminal profiles (iTerm2+)
│   ├── text_buffer.c/h      # Text manipulation
│   ├── cursor_math.c/h      # Mathematical positioning
│   ├── terminal_manager.c/h # Terminal interface using termcap
│   ├── *.c *.h              # Other LLE components
│   └── meson.build          # Build configuration
├── tests/line_editor/        # LLE tests
│   ├── test_*.c             # Unit tests including termcap tests
│   ├── benchmark.c          # Performance tests
│   └── meson.build          # Test configuration
├── docs/line_editor/         # LLE documentation
├── LLE_DEVELOPMENT_TASKS.md  # 50 atomic tasks breakdown
├── LLE_DEVELOPMENT_WORKFLOW.md # Development process
└── LLE_PROGRESS.md          # Current progress tracking
```

## 🎯 STATE SYNCHRONIZATION INTEGRATION (MANDATORY)
AI assistants MUST integrate the unified display state synchronization system:

### ✅ **SOLUTION IMPLEMENTED (Ready for Integration)**
- **Bidirectional state tracking** - Complete terminal-display synchronization system
- **State validation engine** - Automatic consistency checking and recovery
- **Cross-platform support** - Linux display corruption eliminated
- **Performance optimized** - <10μs overhead with intelligent batching
- **Comprehensive testing** - Full test suite validates all functionality

### 🔧 **INTEGRATION REQUIRED (Critical Priority)**
- **Replace terminal operations** - Migrate to state-synchronized functions
- **Add state validation** - Include consistency checking in complex operations
- **Enable debug instrumentation** - Use comprehensive state tracking
- **Cross-platform testing** - Validate on both Linux and macOS

### 🎯 **DEVELOPMENT PRIORITY (INTEGRATION FOCUS)**
**PRIMARY OBJECTIVE**: Integrate unified state synchronization to eliminate display issues
- Success criteria: Perfect terminal-display state consistency, zero divergence
- Pattern: lle_display_integration_*() functions replace direct terminal operations
- Enable automatic state validation and recovery mechanisms
- Focus on eliminating "display state never matched terminal state" problems

## Termcap Integration Architecture
LLE includes a complete termcap system transferred from Lusush to ensure standalone operation:
- **No External Dependencies**: Complete terminal capability system included
- **iTerm2 Support**: Full macOS and iTerm2 compatibility preserved
- **Terminal Database**: 50+ terminal profiles including modern terminals
- **Namespaced API**: All termcap functions prefixed with `lle_` for standalone use

Each task is 2-4 hours of work with clear acceptance criteria and tests.

## Code Standards for LLE
```c
// Function naming: lle_component_action
bool lle_text_insert_char(lle_text_buffer_t *buffer, char c);

// Termcap functions: lle_termcap_action (namespaced from Lusush)
bool lle_termcap_init(void);
bool lle_termcap_is_iterm2(void);
bool lle_termcap_set_color(lle_termcap_color_t fg, lle_termcap_color_t bg);

// Structure naming: lle_component_t
typedef struct {
    char *buffer;
    size_t length;
    size_t capacity;
} lle_text_buffer_t;

// Error handling: always return bool for success/failure
bool lle_function(args) {
    if (!args) return false;
    // implementation
    return true;
}

// Documentation: comprehensive function docs
/**
 * Insert character at cursor position in text buffer.
 *
 * @param buffer Text buffer to modify
 * @param c Character to insert
 * @return true on success, false on error
 *
 * Buffer automatically resizes if needed. Cursor advances by one.
 * Handles UTF-8 encoding correctly.
 */
```

## Build Commands (Meson-based)
```bash
# Setup (first time)
scripts/lle_build.sh setup

# Build LLE
scripts/lle_build.sh build

# Run tests
scripts/lle_build.sh test

# Run specific test
meson test -C builddir test_text_buffer

# Performance benchmarks
scripts/lle_build.sh benchmark

# Clean rebuild
scripts/lle_build.sh clean && scripts/lle_build.sh setup
```

## Key Design Principles
1. **Mathematical Correctness**: All cursor positioning must be mathematically provable
2. **Performance**: Sub-millisecond response times required
3. **Unicode Support**: Proper UTF-8 handling throughout
4. **Theme Integration**: Deep integration with Lusush theme system
5. **Modular Architecture**: Each component independently testable
6. **Memory Safety**: No leaks, proper bounds checking
7. **Terminal Compatibility**: Works across all terminal types

## Current Task Context
Check `LLE_PROGRESS.md` for current task. Each task has:
- **Task ID**: LLE-XXX format
- **Estimated Time**: Usually 2-4 hours
- **Files to Modify**: Specific source files
- **Acceptance Criteria**: Clear success metrics
- **Tests Required**: Specific test cases
- **Commit Message**: Pre-planned format

## Testing Requirements
Every task must include:
- **Unit Tests**: Test individual functions
- **Integration Tests**: Test component interactions
- **Edge Cases**: Boundary conditions and error cases
- **Performance Tests**: Response time validation
- **Memory Tests**: Leak detection with Valgrind

### Common Development Patterns

### Text Buffer Operations
```c
// Always check buffer validity
if (!buffer || !buffer->buffer) return false;

// Ensure capacity before operations
if (buffer->length + new_data_size >= buffer->capacity) {
    if (!lle_text_buffer_resize(buffer, new_capacity)) return false;
}

// Update both byte and character counts
buffer->length += bytes_added;
buffer->char_count += chars_added;
```

### Cursor Position Calculations
```c
// Use the mathematical framework
lle_cursor_position_t pos = lle_calculate_cursor_position(
    buffer, geometry, prompt_width
);

// Always validate results
if (!pos.valid) {
    // Handle error case
    return false;
}
```

### Terminal Operations Using Integrated Termcap
```c
// Initialize integrated termcap system
if (!lle_termcap_init()) return false;

// Use namespaced termcap functions
lle_termcap_set_color(LLE_TERMCAP_COLOR_GREEN, LLE_TERMCAP_COLOR_BLACK);
lle_termcap_move_cursor(row, col);

// Check for specific terminal capabilities
if (lle_termcap_is_iterm2()) {
    // iTerm2-specific optimizations
}

// Terminal manager wraps termcap functionality
if (!lle_terminal_init(tm)) return false;
lle_terminal_write(tm, data, length);
```

## Integration Points with Existing Lusush
- **Theme System**: `src/themes.c` - LLE provides theme support interface
- **Integrated Termcap**: `src/line_editor/termcap/` - Complete termcap system transferred from Lusush
- **Configuration**: `src/config.c` - LLE respects user settings via API
- **Main Shell**: `src/lusush.c` - LLE replaces linenoise calls as standalone library

## Standalone Library Design
- **Self-Contained**: No external termcap dependencies
- **Reusable**: Can be used by other projects like libhashtable
- **Complete**: Includes all necessary terminal capabilities
- **Compatible**: Maintains all Lusush terminal features including iTerm2

## Performance Requirements
- Character insertion: < 1ms
- Cursor movement: < 1ms
- Display update: < 5ms
- History search: < 10ms
- Tab completion: < 50ms
- Memory usage: < 1MB base, < 50 bytes per character

## Common Gotchas
1. **UTF-8**: Always distinguish between byte position and character position
2. **Terminal Width**: Account for ANSI escape sequences in width calculations
3. **Cursor Math**: Line wrapping must be mathematically exact
4. **Memory Management**: Every malloc needs corresponding free
5. **Error Handling**: Never ignore return values, always check for NULL
6. **Thread Safety**: LLE is single-threaded by design
7. **Signal Handling**: Graceful cleanup on SIGINT/SIGTERM

## Development Workflow
1. **Pick Next Task**: Check `LLE_PROGRESS.md` for TODO tasks
2. **Create Branch**: `git checkout -b task/lle-XXX-description`
3. **Read Task Spec**: Full requirements in `LLE_DEVELOPMENT_TASKS.md`
4. **Implement**: Follow code standards and design principles
5. **Write Tests**: Comprehensive test coverage required
6. **Run Tests**: `scripts/lle_build.sh test`
7. **Commit**: Use task-specific commit message format
8. **Update Progress**: Mark task as DONE in `LLE_PROGRESS.md`

## Debug Information
```bash
# Enable debug output
export LLE_DEBUG=1
export LLE_DEBUG_CURSOR=1
export LLE_DEBUG_MEMORY=1

# Run with debugger
gdb builddir/lusush
(gdb) set environment LLE_DEBUG=1
(gdb) run

# Memory leak detection
valgrind --leak-check=full builddir/lusush

# Performance profiling
perf record builddir/lusush
perf report
```

## Quick Reference: Key Files to Understand
- `LLE_DEVELOPMENT_TASKS.md` - Complete task breakdown
- `LLE_DEVELOPMENT_WORKFLOW.md` - Process and quality standards
- `LINE_EDITOR_STRATEGIC_ANALYSIS.md` - Why we're building LLE
- `src/line_editor/` - Current LLE implementation
- `tests/line_editor/` - Test suite
- `LLE_PROGRESS.md` - Current development status

## 🎯 **STATE SYNCHRONIZATION INTEGRATION - START HERE

### 🎯 IMMEDIATE ACTION FOR NEXT AI ASSISTANT
**YOUR FIRST ACTION**: Integrate unified display state synchronization system.

**CONTEXT**: Display state divergence is root cause of corruption. User identified: "display state never matched terminal state especially after ANSI clear sequences". Complete solution implemented.

### 🎯 MANDATORY INTEGRATION PROTOCOL
1. **🎯 REPLACE TERMINAL OPERATIONS**: Migrate lle_terminal_write() to lle_display_integration_terminal_write()
2. **🎯 ADD STATE VALIDATION**: Include lle_display_integration_validate_state() after complex operations
3. **🎯 ENABLE STATE TRACKING**: Initialize lle_display_integration_t in display initialization
4. **🎯 TEST CROSS-PLATFORM**: Validate perfect synchronization on Linux and macOS

### 🎯 MANDATORY READING (NO EXCEPTIONS)
AI assistants MUST read these files before any implementation:
1. **`UNIFIED_DISPLAY_STATE_SOLUTION.md`** - Complete architectural solution (REQUIRED)
2. **`DISPLAY_STATE_SYNC_INTEGRATION_GUIDE.md`** - Step-by-step integration guide (REQUIRED)
3. **`DISPLAY_STATE_FIX_EXAMPLE.md`** - Practical code examples (REQUIRED)
4. **`NEXT_AI_ASSISTANT_QUICK_START.md`** - Quick integration overview (REQUIRED)
5. **`AI_CONTEXT.md`** - Updated context with state sync focus (REQUIRED)

### 🚨 CODING STANDARDS VIOLATIONS WILL BE REJECTED
Any code that violates these standards will be rejected:

#### ❌ NAMING VIOLATIONS (AUTOMATIC REJECTION)
- Functions MUST use `lle_component_action` pattern exactly
- Structures MUST use `lle_component_t` pattern exactly
- No generic names, no non-LLE prefixes
- Examples: `lle_completion_extract_word()`, `lle_completion_item_t`

#### ❌ DOCUMENTATION VIOLATIONS (AUTOMATIC REJECTION)
- All functions MUST have comprehensive Doxygen documentation
- MUST include `@brief`, `@param`, `@return` tags
- MUST include behavior descriptions and error conditions
- Example pattern in this file (lines 78-88)

#### ❌ MEMORY SAFETY VIOLATIONS (AUTOMATIC REJECTION)
- MUST use `memcpy()` instead of `strcpy()` or `strncpy()`
- MUST validate all parameters before use
- MUST check buffer bounds before operations
- MUST return `bool` for success/failure

#### ❌ TEST FRAMEWORK VIOLATIONS (AUTOMATIC REJECTION)
- Use `LLE_TEST(name)` macro WITHOUT `test_` prefix
- Call functions WITH `test_` prefix in main()
- Example: `LLE_TEST(basic_functionality)` creates `test_basic_functionality()`
- MUST include edge cases and parameter validation tests

#### ❌ BUILD INTEGRATION VIOLATIONS (AUTOMATIC REJECTION)
- MUST include all necessary headers (`stdio.h` for `snprintf`, etc.)
- MUST add new test files to `tests/line_editor/meson.build`
- MUST compile without warnings
- MUST pass all existing tests

### ✅ REQUIRED WORKFLOW
1. Read documentation files listed above
2. Understand current task from `LLE_PROGRESS.md`
3. Study existing patterns in similar completed tasks
4. Implement following EXACT naming and documentation patterns
5. Write comprehensive tests using LLE test framework
6. Build and test: `scripts/lle_build.sh build && scripts/lle_build.sh test`
7. Commit with proper LLE format: `LLE-XXX: Description`

## 🚨 AI Assistant Guidelines - INTERACTIVE REALITY FIRST

### **MANDATORY FIRST ACTIONS**
1. **Read `IMMEDIATE_AI_HANDOFF.md`** - Understand breakthrough success and current status
2. **Continue exact backspace replication approach** - NO major changes to working pattern
3. **Focus on cursor position refinement** - Fix 2-character visual artifact only
4. **Preserve working implementation** - lle_cmd_backspace/lle_cmd_insert_char pattern successful

### **DEVELOPMENT CONSTRAINTS**
- Visual terminal behavior is the only measure of success
- Mathematical correctness means nothing if visual result is wrong
- Debug logs show calculations but not visual reality
- Human testing is mandatory - no exceptions

### **TECHNICAL REQUIREMENTS**
- Use Meson build commands, not Make
- Follow space-and-backspace clearing pattern (proven working)
- Avoid display system rendering (causes prompt cascading)
- Avoid ANSI escape sequences (unreliable)
- Maintain exact character counting (works correctly)

## 🚨 Emergency Protocols - Multiline Clearing Focus

### **If Multiline Clearing Attempts Fail**
1. **Stop immediately** - no further attempts without human guidance
2. **Request debug logs** from human testing: `LLE_DEBUG=1 ./builddir/lusush 2>/tmp/debug.log`
3. **Analyze visual behavior** - not just mathematical calculations
4. **Revert to working state** if breaking single-line functionality
5. **Document findings** in interactive reality terms

### **Build and Test Commands**
- Build: `scripts/lle_build.sh build`
- Test interactively: `LLE_DEBUG=1 ./builddir/lusush`
- Debug logs: `LLE_DEBUG=1 LLE_CURSOR_DEBUG=1 ./builddir/lusush 2>/tmp/debug.log`
- Human testing verification required for every change

## 🚨 FINAL WARNING TO AI ASSISTANTS - INTERACTIVE REALITY COMPLIANCE

### **MANDATORY REQUIREMENTS**
Any AI assistant working on LLE MUST:
1. **Read and follow `LLE_INTERACTIVE_REALITY.md`** - No exceptions
2. **Focus exclusively on multiline history clearing** - NO other features
3. **Request human testing verification** for every change
4. **Use only proven working patterns** - space-and-backspace for single-line
5. **Acknowledge visual terminal behavior as only success measure**

### **AUTOMATIC REJECTION CRITERIA**
Code will be REJECTED if:
- Changes the successful lle_cmd_backspace/lle_cmd_insert_char approach
- Attempts complex clearing logic instead of refining current pattern
- Ignores user feedback that current approach is working excellently
- Works on features other than refining cursor position calculation
- Doesn't preserve the working exact backspace replication implementation
- Doesn't understand this is a minor refinement, not a major rewrite

### **EXACT BACKSPACE REPLICATION PATTERN**
The working approach (needs minor refinement):
1. ✅ IMPLEMENTED: lle_cmd_move_end() to position cursor at end
2. ✅ IMPLEMENTED: lle_cmd_backspace() loop using cursor_pos count
3. ✅ IMPLEMENTED: lle_cmd_insert_char() for new content insertion
4. ✅ WORKING: Terminal positioning handled correctly by existing functions
5. 🔧 REFINEMENT NEEDED: Cursor position calculation for perfect visual clearing

## 🎯 MANDATORY IMPLEMENTATION PATTERN

**EXACT BACKSPACE REPLICATION APPROACH**:
1. **Count old content characters** → Determine exact backspace count needed
2. **Send backspace sequence** → for each character: write("\b \b")
3. **Write new content** → Write new history content after clearing
4. **Let terminal handle positioning** → No cursor manipulation, no prompt redraws
5. **Human verification required** → Must be confirmed working by user testing

**FORBIDDEN APPROACHES**:
Complex clearing → Prompt redraws → Multiline detection → Display manipulation → Making things worse

**SUCCESS**: Exact backspace replication using lle_cmd_backspace() is working excellently. User feedback: "happiest user has been with history recall". Approach is correct and successful.

**Integrate unified display state synchronization system. Solution is complete and tested - needs integration into existing codebase to eliminate display state divergence permanently.**
